<html><body><h1>Name: The Opera</h1><h3>Artist: Luke Shannon</h3><h3>Description: On a cosmic stage, these actors sing an infinite song. What do they reach for? Who are they searching for? Do their faces show wonderâ€”or sadness? Sometimes they sing for themselves, sometimes they sing for the crowd, and sometimes they sing for the void. Like us. (25% to environmental charities)</h3><h3>https://twitter.com/bad_monk</h3><hr/><p>Script JSON: {&quot;type&quot;:&quot;p5js&quot;,&quot;aspectRatio&quot;:&quot;1&quot;}</p><p>Script Type: p5js</p><p>Version: </p><p>Script Ratio: 1</p><p>Instructions: </p><p>Hashes Generated per Token: true</p><p>Dynamic Asset? true</p><hr/><p>Artist Ethereum Address: 0xc7d7852c8936cffd7903e07ce0758527c4b3e9a1</p><p>Additional Payee: 0x19d690a204e2b3f6fd7ef893f08d7ce4f4375625</p><p>Additional Payee Percentage: 0</p><p>Price: 0.1</p><p>Currency: ETH</p><p>Currency Address: N/A</p><p>Invocations: 256</p><p>Maximum Invocations: 256</p><p>License: NFT License</p><p>Token Ids: 50000000,50000001,50000002,50000003,50000004,50000005,50000006,50000007,50000008,50000009,50000010,50000011,50000012,50000013,50000014,50000015,50000016,50000017,50000018,50000019,50000020,50000021,50000022,50000023,50000024,50000025,50000026,50000027,50000028,50000029,50000030,50000031,50000032,50000033,50000034,50000035,50000036,50000037,50000038,50000039,50000040,50000041,50000042,50000043,50000044,50000045,50000046,50000047,50000048,50000049,50000050,50000051,50000052,50000053,50000054,50000055,50000056,50000057,50000058,50000059,50000060,50000061,50000062,50000063,50000064,50000065,50000066,50000067,50000068,50000069,50000070,50000071,50000072,50000073,50000074,50000075,50000076,50000077,50000078,50000079,50000080,50000081,50000082,50000083,50000084,50000085,50000086,50000087,50000088,50000089,50000090,50000091,50000092,50000093,50000094,50000095,50000096,50000097,50000098,50000099</p><p>Active? true</p><p>Paused? false</p><hr/><p><strong>Script:</strong></p><pre>let rw = su(tokenData),
     s = gs(tokenData),
     d = {
          hyper: rw[1] &lt; .03,
          type: wP([&quot;p&quot;, &quot;c&quot;, &quot;f&quot;], [1, 2, 17], rw[2]),
          colors: wP([
               [&quot;#aa9387&quot;, &quot;#fdf1d3&quot;, &quot;#f7bfb1&quot;, &quot;#f19d54&quot;, &quot;#a16f5c&quot;],
               [&quot;#fac901&quot;, &quot;#225095&quot;, &quot;#dd0100&quot;, &quot;#ffffff&quot;],
               [&quot;#d8e0bb&quot;, &quot;#b6cec7&quot;, &quot;#86a3c3&quot;, &quot;#7268a6&quot;, &quot;#6b3074&quot;],
               [&quot;#173F5F&quot;, &quot;#20639B&quot;, &quot;#3CAEA3&quot;, &quot;#f6d55c&quot;, &quot;#ed553b&quot;],
               [&quot;#5f0f40&quot;, &quot;#9a031e&quot;, &quot;#fb8b24&quot;, &quot;#e36414&quot;, &quot;#0f4c5c&quot;],
               [&quot;#f18c8e&quot;, &quot;#f0b7a4&quot;, &quot;#f1d1b5&quot;, &quot;#568ea6&quot;, &quot;#305f72&quot;],
               [&quot;#fffcf2&quot;, &quot;#ccc5b9&quot;, &quot;#403d39&quot;, &quot;#252422&quot;, &quot;#eb5e28&quot;],
               [&quot;#322c4d&quot;, &quot;#cfc4ff&quot;, &quot;#f5b649&quot;, &quot;#19211e&quot;, &quot;#303757&quot;],
               [&quot;#0e0e1b&quot;, &quot;#204829&quot;, &quot;#22b455&quot;, &quot;#80ce87&quot;, &quot;#92e5a1&quot;]
          ], [3, 3, 3, 3, 2, 1, 1, 1, 1], rw[3]),
          paper: wP([&quot;#363333&quot;, &quot;#FAF5E8&quot;, &quot;#F3EEDF&quot;, &quot;#F2EAD0&quot;, &quot;#D0CBBA&quot;, &quot;#FAEDCD&quot;], [1, 1, 1, 1, 1, 1], rw[4]),
          ppl: wP([3, 2, 1], [1, 3, 21], rw[5])
     };

function makeP(t) {
     return {
          lE: rw[6 + t] &lt; .9,
          rE: rw[7 + t] &lt; .9,
          m: rw[8 + t] &lt; .6,
          lA: rw[9 + t] &lt; .7,
          rA: rw[10 + t] &lt; .7,
          lAH: rw[11 + t] &lt; .2,
          rAH: rw[12 + t] &lt; .2
     }
}
let bC, bg, sC, fC, rz, w, v, sW, e, ci, st, ps = [],
     wV = [],
     cs = [],
     n = 1e3;

function setup() {
     w = min(windowWidth, windowHeight), v = vertex, st = stroke, sW = strokeWeight, e = ellipse, ci = circle, createCanvas(w, w), rz = w / 1e3, noiseSeed(s);
     for (let t = 0; t &lt; d.ppl; t++) d.i = makeP(7 * t), ps.push(new P(ra(w / 2) + w / 4, w - 200 * rz, 100, 100, d.i.lE, d.i.rE, d.i.m, d.i.lA, d.i.rA, d.i.lAH, d.i.rAH, 500, 300, 50, 50, 50, 50, 50, 1e3 * t, 0));
     if (print(tokenData.hash, d), sW(1 * rz), bg = pi(d.colors), d.colors.splice(d.colors.indexOf(bg), 1), sC = pi(d.colors), bC = pi(d.colors), fC = pi([bg, pi(d.colors)]), &quot;c&quot; == d.type)
          for (let t = 0; t &lt; 250; t++) ps.unshift(new P(ra(w), w - w / 250 * t, ra(15) + 10, ra(15) + 20, rnd() &gt; 1e-4, rnd() &gt; 1e-4, 0, 0, 0, 0, 0, 50, 30, 5, 5, 0, 0, 0, 10 * t, 0));
     else if (&quot;f&quot; == d.type) {
          for (let t = 0; t &lt; 1; t++) wV.push([ra(w / 2), ra(20), (ra(3) + 2) * rz, ra(60) * rz, ra(50) * rz, (ra(10) + 2) * rz, ra(300) * rz]);
          for (let t = 0; t &lt; 30 * noise(10); t++) cs.push([ra(w), ra(w), ra(80) * rz, pi(d.colors)])
     } else if (&quot;p&quot; == d.type) {
          n = 300;
          let t = 1;
          for (let s = 0; s &lt; 3; s++) t += rnd() &gt; 1 / 2 ** s;
          for (let s = 0; s &lt; t; s++) {
               let t = ra(3 * w / 4) + w / 8,
                    s = ra(4 * w / 5) + w / 10,
                    r = (ra(200) + 80) * rz,
                    i = r + (120 + ra(300)) * rz,
                    e = r - ra(3 * r / 4) * rz;
               cs.push([ra(3 * w / 4) + w / 8, ra(4 * w / 5) + w / 10, (ra(200) + 80) * rz, ra(PI / 2), rnd() &gt; .7, max(i, e), min(i, e)]);
               for (let i of cs) dist(t, s, i[0], i[1]) &lt; r &amp;&amp; t != i[0] &amp;&amp; s != i[1] &amp;&amp; cs.splice(cs.length - 1, 1);
               ps[0].rot = ra(TAU), ps[0].x = w / 2, ps[0].y = w / 2
          }
     }
}

function draw() {
     if (background(bg), &quot;f&quot; == d.type) {
          for (let t of wV) wL(t[0], t[1], t[2], t[3], t[4], t[5], t[6]);
          for (let t of cs) fill(t[3]), ci(t[0], t[1], 2 * t[2])
     } else &quot;p&quot; == d.type &amp;&amp; (dP(), fill(sC), e(w / 2, w, 2 * w, w / 2));
     for (let t of ps) t.draw(), t.t += .002, d.hyper &amp;&amp; (t.t += .009);
     dB()
}

function dB() {
     push(), fill(d.paper), beginShape(), v(0, 0), v(w, 0), v(w, w), v(0, w), beginContour(), v(w - 80 * rz, w - 80 * rz), v(w - 80 * rz, 80 * rz), v(80 * rz, 80 * rz), v(80 * rz, w - 80 * rz), endContour(), endShape(CLOSE), pop()
}

function wL(t, s, r, i, e, h, l) {
     push(), fill(sC), noStroke(), translate(t, 0);
     for (let t = -e * s; t &lt; w + e * s; t += h)
          for (let h = 0; h &lt; s; h += 1) ci(100 * sin(t / l + frameCount / 200) * rz + h * i, t + h * e, 2 * r);
     pop()
}

function dP(t) {
     for (let t of cs) {
          push();
          let s = t[2],
               r = t[5],
               i = t[6];
          translate(t[0], t[1]), fill(bg), ci(0, 0, s + 8 * rz), fill(sC), ci(0, 0, s), t[4] &amp;&amp; (rotate(-t[3]), push(), noFill(), sW(32 * rz), st(0), e(0, 0, r, i), sW(30 * rz), st(bg), e(0, 0, r, i), sW(15 * rz), st(sC), e(0, 0, r, i), pop(), fill(bg), arc(0, 0, s + 8 * rz, s + 8 * rz, PI, TAU), fill(sC), arc(0, 0, s, s, PI - .01, TAU + .01), noStroke(), arc(0, -2 * rz, s - 15, s - 15, PI, TAU)), pop()
     }
}
class P {
     constructor(t, s, r, i, e, h, l, n, f, o, a, p, c, w, d, u, b, z, A, N) {
          this.x = t, this.y = s, this.b = r, this.h = i, this.lE = e, this.rE = h, this.m = l, this.lA = n, this.rA = f, this.lAH = o, this.rAH = a, this.hN = p, this.bN = c, this.rEN = w, this.lEN = d, this.mN = u, this.lAN = b, this.rAN = z, this.nO = A, this.rot = N, this.t = 0, this.p = [
               [0, 2.8, 0],
               [0, 2.8, 0],
               [-1, 3, 0],
               [-1, 2, 0],
               [-.75, 1, 0],
               [-.5, -.25, 0],
               [-.4, -.75, 1],
               [-.75, -1.5, 1],
               [-.45, -2.3, 1],
               [0, -2.5, 1]
          ];
          for (let t = this.p.length - 2; t &gt;= 0; t--) this.p.push([-this.p[t][0], this.p[t][1], this.p[t][2]]);
          this.lap = [
               [-.7, .7],
               [-.65, .4],
               [-.6, .2],
               [-.56, 0]
          ], this.rap = [
               [.56, 0],
               [.6, .2],
               [.65, .4],
               [.7, .7]
          ]
     }
     draw() {
          push(), translate(this.x, this.y), rotate(this.rot), fill(bC), beginShape();
          for (let t = 0; t &lt; this.p.length; t++) {
               let s = this.p[t][2],
                    r = s ? this.h : this.b,
                    i = s ? this.hN : this.bN;
               if (this.lA &amp;&amp; 5 == t)
                    for (let t = 0; t &lt; this.lap.length; t++) {
                         let s = 3;
                         t &gt; 0 &amp;&amp; t &lt; 3 &amp;&amp; (s = 10);
                         let e = this.cN(this.lap[t][0], this.lap[t][1], r, i, this.lAN * s, 0, this.t + this.nO);
                         curveVertex(e[0], e[1])
                    }
               if (this.rA &amp;&amp; 14 == t)
                    for (let t = 0; t &lt; this.rap.length; t++) {
                         let s = 3;
                         t &gt; 0 &amp;&amp; t &lt; 3 &amp;&amp; (s = 10);
                         let e = this.cN(this.rap[t][0], this.rap[t][1], r, i, this.rAN * s, 1, this.t + this.nO);
                         curveVertex(e[0], e[1])
                    }
               let e = this.cN(this.p[t][0], this.p[t][1], r, i, 1, 0, this.t + this.nO);
               curveVertex(e[0], e[1])
          }
          endShape(), fill(fC);
          let t = this.cN(-.3, -1.8, this.h, this.hN, this.lEN, 0, this.t + this.nO);
          if (this.lE ? ci(t[0], t[1], 20 * rz) : this.xE(t[0], t[1], 10 * rz), t = this.cN(.3, -1.8, this.h, this.hN, this.rEN, 0, this.t + this.nO), this.rE ? ci(t[0], t[1], 20 * rz) : this.xE(t[0], t[1], 10 * rz), this.m) {
               let t = this.cN(0, -1.25, this.h, this.hN, this.mN, 0, this.t + this.nO);
               ci(t[0], t[1], (70 * noise(0) + 2) * rz)
          }
          if (this.lA &amp;&amp; this.lAH) {
               let t = this.cN(this.lap[2][0], this.lap[2][1], this.b, this.bN, 10 * this.lAN, 0, this.t + this.nO);
               ci(t[0], t[1], 40 * rz)
          }
          if (this.rA &amp;&amp; this.rAH) {
               let t = this.cN(this.rap[1][0], this.rap[1][1], this.b, this.bN, 10 * this.rAN, 1, this.t + this.nO);
               ci(t[0], t[1], 40 * rz)
          }
          pop()
     }
     xE(t, s, r) {
          push(), st(sC), sC == bC &amp;&amp; st(0), sW(4 * rz), line(t - r / 2, s - r / 2, t + r / 2, s + r / 2), line(t + r / 2, s - r / 2, t - r / 2, s + r / 2), pop()
     }
     cN(t, s, r, i, e, h, l) {
          let f = t * r,
               o = s * r,
               a = f + noise(f / n + 10 + h, o / n + 10 + this.nO, l) * (i + e) - i / 2 - e / 2,
               p = o + noise(f / n + 50 + h, o / n + 50 + this.nO, l) * (i + e) - i / 2 - e / 2;
          return [a * rz, p * rz]
     }
}

function su(t) {
     let s = [];
     for (let r = 0; r &lt; 32; r++) s.push(t.hash.slice(2 + 2 * r, 4 + 2 * r));
     return s.map(t =&gt; parseInt(t, 16) / 255)
}

function gs(t) {
     return parseInt(t.hash.slice(0, 16), 16)
}

function rnd() {
     return s ^= s &lt;&lt; 13, s ^= s &gt;&gt; 17, ((s ^= s &lt;&lt; 5) &lt; 0 ? 1 + ~s : s) % 1e3 / 1e3
}

function ra(t, s = -1) {
     return -1 === s &amp;&amp; (s = t, t = 0), rnd() * (s - t) + t
}

function rF(t, s) {
     return Math.floor(ra(t, s))
}

function wP(t, s, r) {
     let i;
     for (i = 0; i &lt; s.length; i++) s[i] += s[i - 1] || 0;
     var e = r * s[s.length - 1];
     for (i = 0; i &lt; s.length &amp;&amp; !(s[i] &gt;= e); i++);
     return t[i]
}

function pi(t) {
     return t[rF(0, t.length)]
}</pre></body></html>