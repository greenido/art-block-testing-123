<html><body><h1>Name: P:X</h1><h3>Artist: mightymoose</h3><h3>Description: Six simple objects. Three rectangles and three circles. Complexity through simplicity. Chaos to form and back again. The animations designed as art, sit back and enjoy the movements. 
You can pause the animation by clicking on the image</h3><h3>https://twitter.com/mightymooseART</h3><hr/><p>Script JSON: {&quot;type&quot;:&quot;p5js&quot;,&quot;instructions&quot;:&quot;Animations happen automatically after a variable number of pulses | you can pause the animation by clicking on the image&quot;,&quot;interactive&quot;:&quot;true&quot;,&quot;aspectRatio&quot;:&quot;1&quot;,&quot;version&quot;:&quot;1.0.0&quot;,&quot;curation_status&quot;:&quot;factory&quot;}</p><p>Script Type: p5js</p><p>Version: 1.0.0</p><p>Script Ratio: 1</p><p>Instructions: Animations happen automatically after a variable number of pulses | you can pause the animation by clicking on the image</p><p>Hashes Generated per Token: true</p><p>Dynamic Asset? true</p><hr/><p>Artist Ethereum Address: 0xbd72d021d3cb334deb3151db905ee073b8eee518</p><p>Additional Payee: 0x0f13316b80872eda120d7844ed1c1e90fc001dc1</p><p>Additional Payee Percentage: 40</p><p>Price: 0.1624</p><p>Currency: ETH</p><p>Currency Address: N/A</p><p>Invocations: 384</p><p>Maximum Invocations: 384</p><p>License: NIFTY License</p><p>Token Ids: 54000000,54000001,54000002,54000003,54000004,54000005,54000006,54000007,54000008,54000009,54000010,54000011,54000012,54000013,54000014,54000015,54000016,54000017,54000018,54000019,54000020,54000021,54000022,54000023,54000024,54000025,54000026,54000027,54000028,54000029,54000030,54000031,54000032,54000033,54000034,54000035,54000036,54000037,54000038,54000039,54000040,54000041,54000042,54000043,54000044,54000045,54000046,54000047,54000048,54000049,54000050,54000051,54000052,54000053,54000054,54000055,54000056,54000057,54000058,54000059,54000060,54000061,54000062,54000063,54000064,54000065,54000066,54000067,54000068,54000069,54000070,54000071,54000072,54000073,54000074,54000075,54000076,54000077,54000078,54000079,54000080,54000081,54000082,54000083,54000084,54000085,54000086,54000087,54000088,54000089,54000090,54000091,54000092,54000093,54000094,54000095,54000096,54000097,54000098,54000099</p><p>Active? true</p><p>Paused? false</p><hr/><p><strong>Script:</strong></p><pre>var seedA = parseInt(tokenData.hash.slice(0, 16), 16);
let azonosito = parseInt(tokenData.tokenId),
     propKey = [],
     propValue = [],
     isPaused = !1,
     cFrameCount = 0,
     itsStage = 0,
     A = [0],
     canvas, frameA, frameB, frameC, frameD, frameE, aX, aY, aR, aXp, aYp, aRp, bX, bY, bR, bXp, bYp, bRp, cX, cY, cR, cXp, cYp, cRp, dX, dY, dR, dXp, dYp, dRp, eX, eY, eR, eXp, eYp, eRp, fX, fY, fR, fXp, fYp, fRp, bRad, cRad, dRad, bRadp, cRadp, dRadp, pdotColR, pdotColG, pdotColB, pdotColA, dpdotColR, dpdotColG, dpdotColB, dpdotColA, pdotMul, dpdotMul, pulses = 0,
     pulseInterval, thecols = [
          [35, 43, 43, 255],
          [248, 248, 255, 255],
          [255, 223, 0, 255],
          [255, 5, 5, 255],
          [46, 255, 83, 255],
          [254, 125, 5, 255],
          [215, 25, 144, 255],
          [0, 184, 200, 255],
          [9, 120, 255, 255],
          [0, 0, 0, 255]
     ],
     colnames = [&quot;Ghost Black&quot;, &quot;Ghost White&quot;, &quot;Yellow&quot;, &quot;Red&quot;, &quot;Green&quot;, &quot;Orange&quot;, &quot;Pink&quot;, &quot;Cyan&quot;, &quot;Blue&quot;, &quot;Black&quot;],
     bgcol = [255, 255, 255, 255],
     fgcol = [0, 0, 0, 255],
     thecolsalt = [
          [70, 60, 254, 255],
          [84, 200, 100, 255],
          [230, 0, 154, 255],
          [255, 100, 29, 255]
     ],
     interval = 120,
     stageAdvance, which = -1;

function AreAffinitous(p, e, s, a, i, o) {
     return Math.abs(p - a) &lt; s / 2 + o / 2 &amp;&amp; Math.abs(e - i) &lt; s / 2 + o / 2
}

function setup() {
     window.location.search;
     which = azonosito, 999999 &lt; which &amp;&amp; (which -= 1e6 * int(which / 1e6)), propKey.push(&quot;ID&quot;), propValue.push(which), interval = int(map(rnd(), 0, 1, 75, 125)), 2 != which &amp;&amp; 61 != which &amp;&amp; 173 != which &amp;&amp; 313 != which &amp;&amp; 11 != which &amp;&amp; 89 != which &amp;&amp; 211 != which &amp;&amp; 349 != which &amp;&amp; 29 != which &amp;&amp; 107 != which &amp;&amp; 233 != which &amp;&amp; 367 != which &amp;&amp; 43 != which &amp;&amp; 149 != which &amp;&amp; 277 != which &amp;&amp; 383 != which || (interval = int(map(rnd(), 0, 1, 115, 125))), propKey.push(&quot;Speed&quot;), propValue.push(50 - (interval - 75) + 75), outputsize = windowWidth &gt;= windowHeight ? windowHeight : windowWidth, createCanvas(outputsize, outputsize), setAttributes(&quot;antialias&quot;, !0), background(bgcol), setsize(), pulseInterval = int(map(rnd(), 0, 1, 0, 100)) &lt; 80 ? int(map(rnd(), 0, 1, 3, 5)) : int(map(rnd(), 0, 1, 2, 7)), propKey.push(&quot;Transition Interval&quot;), propValue.push(pulseInterval), colrnum = int(map(rnd(), 0, 1, 0, 384));
     let p;
     p = colrnum &lt; 6 ? 5 : colrnum &lt; 12 ? 6 : colrnum &lt; 18 ? 8 : colrnum &lt; 36 ? 4 : colrnum &lt; 60 ? 7 : colrnum &lt; 90 ? 0 : colrnum &lt; 126 ? 1 : colrnum &lt; 168 ? 2 : colrnum &lt; 216 ? 3 : 9, pdotColR = thecols[p][0], pdotColG = thecols[p][1], pdotColB = thecols[p][2], pdotColA = thecols[p][3], isRandom = !0, 0 &lt; which &amp;&amp; (oldcidx = p, p = -1, 2 != which &amp;&amp; 61 != which &amp;&amp; 173 != which &amp;&amp; 313 != which || (p = 0), 11 != which &amp;&amp; 89 != which &amp;&amp; 211 != which &amp;&amp; 349 != which || (p = 1), 29 != which &amp;&amp; 107 != which &amp;&amp; 233 != which &amp;&amp; 367 != which || (p = 2), 43 != which &amp;&amp; 149 != which &amp;&amp; 277 != which &amp;&amp; 383 != which || (p = 3), 0 &lt;= p &amp;&amp; (isRandom = !1, pdotColR = thecolsalt[p][0], pdotColG = thecolsalt[p][1], pdotColB = thecolsalt[p][2], pdotColA = thecolsalt[p][3], bgcol = [0, 0, 0, 255], fgcol = [255, 255, 255, 255]), p = oldcidx), propKey.push(&quot;Type&quot;), isRandom ? propValue.push(&quot;Generated&quot;) : propValue.push(&quot;Curated&quot;), propKey.push(&quot;Color&quot;), 383 == which ? propValue.push(&quot;Rainbow&quot;) : propValue.push(colnames[p]), dpdotColR = (pdotColR - fgcol[0]) / interval, dpdotColG = (pdotColG - fgcol[1]) / interval, dpdotColB = (pdotColB - fgcol[2]) / interval, dpdotColA = (pdotColA - 255) / interval, pdotUndulates = int(map(rnd(), 0, 1, 0, 100)), pdotMul = 1 + map(rnd(), 0, 1, .3, .8), dpdotMul = (pdotMul - 1) / interval, aX = .2 * size, aY = size / 2, aR = 0, bX = .3 * size, bY = .4 * size, bR = 0, bRad = size / 7, cX = .5 * size, cY = .4 * size, cR = 0, cRad = size / 18, dX = .5 * size, dY = .6 * size, dR = 0, dRad = size / 18, eX = .75 * size, eY = size / 2, eR = HALF_PI / 3, fX = .75 * size, fY = size / 2, fR = HALF_PI / 3 * -1, aXp = size * map(rnd(), 0, 1, .2, .8), aYp = size * map(rnd(), 0, 1, .2, .8), aRp = 3.14 * map(rnd(), 0, 1, -1, 1), aRp = 3.14 * (.125 * int(map(rnd(), 0, 1, 0, 16)) - 1), bXp = size * map(rnd(), 0, 1, .2, .8), bYp = size * map(rnd(), 0, 1, .2, .8), bRp = 3.14 * map(rnd(), 0, 1, -1, 1), bRadp = map(rnd(), 0, 1, size / 18, size / 5), cXp = size * map(rnd(), 0, 1, .2, .8), cYp = size * map(rnd(), 0, 1, .2, .8), cRp = 3.14 * map(rnd(), 0, 1, -1, 1), cRadp = map(rnd(), 0, 1, size / 18, size / 5), dXp = size * map(rnd(), 0, 1, .2, .8), dYp = size * map(rnd(), 0, 1, .2, .8), dRp = 3.14 * map(rnd(), 0, 1, -1, 1), dRadp = map(rnd(), 0, 1, size / 18, size / 5), eXp = size * map(rnd(), 0, 1, .2, .8), eYp = size * map(rnd(), 0, 1, .2, .8), eRp = 3.14 * map(rnd(), 0, 1, -1, 1), eRp = 3.14 * (.125 * int(map(rnd(), 0, 1, 0, 16)) - 1), fXp = size * map(rnd(), 0, 1, .2, .8), fYp = size * map(rnd(), 0, 1, .2, .8), fRp = 3.14 * map(rnd(), 0, 1, -1, 1), fRp = 3.14 * (.125 * int(map(rnd(), 0, 1, 0, 16)) - 1), configNum = map(rnd(), 0, 1, 0, 100), configNumB = map(rnd(), 0, 1, 0, 100), isRandom &amp;&amp; (0 &lt;= configNum &amp;&amp; configNum &lt; 2 &amp;&amp; (fXp = aXp, fYp = aYp, fRp = aRp, propKey.push(&quot;Composition&quot;), propValue.push(&quot;Pclipse&quot;)), 2 &lt;= configNum &amp;&amp; configNum &lt; 6 &amp;&amp; (eXp = aXp, eYp = aYp, eRp = aRp, propKey.push(&quot;Composition&quot;), propValue.push(&quot;Pclipse&quot;)), 6 &lt;= configNum &amp;&amp; configNum &lt; 13 &amp;&amp; (fXp = eXp, fYp = eYp, fRp = eRp, propKey.push(&quot;Composition&quot;), propValue.push(&quot;Xclipse&quot;)), 13 &lt;= configNum &amp;&amp; configNum &lt; 23 &amp;&amp; (fXp = aXp, fYp = size - aYp, fRp = -1 * aRp, propKey.push(&quot;Composition&quot;), propValue.push(&quot;Crossover&quot;)), 23 &lt;= configNum &amp;&amp; configNum &lt; 33 &amp;&amp; (eXp = aXp, eYp = size - aYp, eRp = -1 * aRp, propKey.push(&quot;Composition&quot;), propValue.push(&quot;Crossover&quot;)), 33 &lt;= configNum &amp;&amp; configNum &lt; 43 &amp;&amp; (fXp = eXp, fYp = size - eYp, fRp = -1 * eRp, propKey.push(&quot;Composition&quot;), propValue.push(&quot;Reflections&quot;)), 43 &lt;= configNum &amp;&amp; configNum &lt; 53 &amp;&amp; (fXp = size - aXp, fYp = aYp, fRp = -1 * aRp, propKey.push(&quot;Composition&quot;), propValue.push(&quot;Lazy Crossover&quot;)), 53 &lt;= configNum &amp;&amp; configNum &lt; 63 &amp;&amp; (eXp = size - aXp, eYp = aYp, eRp = -1 * aRp, propKey.push(&quot;Composition&quot;), propValue.push(&quot;Lazy Crossover&quot;)), 63 &lt;= configNum &amp;&amp; configNum &lt; 73 &amp;&amp; (fXp = size - eXp, fYp = eYp, fRp = -1 * eRp, propKey.push(&quot;Composition&quot;), propValue.push(&quot;Lazy Reflections&quot;)), 0 &lt;= configNumB &amp;&amp; configNumB &lt;= 9 &amp;&amp; (bXp = cXp + (size / 50 * map(rnd(), 0, 1, .9, 1.1) - size / 50 / 2), bYp = cYp + (size / 50 * map(rnd(), 0, 1, .9, 1.1) - size / 50 / 2), bRadp = .8 * cRadp, propKey.push(&quot;Composition&quot;), propValue.push(&quot;Hostile Takeover&quot;)), 10 &lt;= configNumB &amp;&amp; configNumB &lt;= 33 &amp;&amp; (bXp = dXp + (size / 50 * map(rnd(), 0, 1, .9, 1.1) - size / 50 / 2), bYp = dYp + (size / 50 * map(rnd(), 0, 1, .9, 1.1) - size / 50 / 2), bRadp = .8 * dRadp, propKey.push(&quot;Composition&quot;), propValue.push(&quot;Preferential Treatment&quot;))), 2 == which &amp;&amp; (aXp = .5 * size, aYp = .75 * size, aRp = 1.57, bXp = .4 * size, bYp = .63 * size, bRp = 0, bRadp = size / 10, cXp = .4 * size, cYp = .45 * size, cRp = 0, cRadp = size / 18, dXp = .6 * size, dYp = .45 * size, dRp = 0, dRadp = size / 18, eXp = .5 * size, eYp = .3 * size, eRp = 3.14 * .4, fXp = .5 * size, fYp = .3 * size, fRp = 3.14 * -.4, pdotMul = 1.25, dpdotMul = (pdotMul - 1) / interval, propKey.push(&quot;Composition&quot;), propValue.push(&quot;Lazy Reflections&quot;)), 11 == which &amp;&amp; (aXp = .2 * size, aYp = .45 * size, aRp = 0, bXp = .5 * size, bYp = .55 * size, bRp = 0, bRadp = size / 6, cXp = .675 * size, cYp = .5 * size, cRp = 0, cRadp = size / 14, dXp = .65 * size, dYp = .65 * size, dRp = 0, dRadp = size / 14, eXp = .275 * size, eYp = .5 * size, eRp = 0, fXp = .35 * size, fYp = .55 * size, fRp = -0, pdotMul = 1.25, dpdotMul = (pdotMul - 1) / interval), 29 == which &amp;&amp; (aXp = .5 * size, aYp = .5 * size, aRp = 1.57, bXp = .5 * size, bYp = .385 * size, bRp = 0, bRadp = size / 9, dXp = .5 * size, dYp = .6 * size, dRp = 0, dRadp = size / 14, cXp = .5 * size, cYp = .35 * size, cRp = 0, cRadp = size / 6, eXp = .5 * size, eYp = .5 * size, eRp = 1.57, fXp = .5 * size, fYp = .5 * size, fRp = 1.57, pdotMul = 1.25, dpdotMul = (pdotMul - 1) / interval, propKey.push(&quot;Composition&quot;), propValue.push(&quot;Hostile Takeover&quot;), propKey.push(&quot;Composition&quot;), propValue.push(&quot;Isolated&quot;)), 43 == which &amp;&amp; (aXp = .5 * size, aYp = .6 * size, aRp = 1.57, bXp = .5 * size, bYp = .375 * size, bRp = 0, bRadp = size / 9, cXp = .4 * size, cYp = .75 * size, cRp = 0, cRadp = size / 14, dXp = .6 * size, dYp = .75 * size, dRp = 0, dRadp = size / 14, eXp = .3 * size, eYp = .35 * size, eRp = 3.14 * .8, fXp = .7 * size, fYp = .35 * size, fRp = 3.14 * .2, pdotMul = 1.25, dpdotMul = (pdotMul - 1) / interval, propKey.push(&quot;Composition&quot;), propValue.push(&quot;Lazy Reflections&quot;)), 61 == which &amp;&amp; (aXp = .54 * size, aYp = .5 * size, aRp = 0, bXp = .4 * size, bYp = .5 * size, bRp = 0, bRadp = size / 9, cXp = .675 * size, cYp = .65 * size, cRp = 0, cRadp = size / 14, dXp = .675 * size, dYp = .35 * size, dRp = 0, dRadp = size / 14, eXp = .6 * size, eYp = .39325 * size, eRp = 2.355, fXp = .6 * size, fYp = .60675 * size, fRp = .785, pdotMul = 1.25, dpdotMul = (pdotMul - 1) / interval, propKey.push(&quot;Composition&quot;), propValue.push(&quot;Reflections&quot;)), 89 == which &amp;&amp; (aXp = .5 * size, aYp = .485 * size, aRp = 0, bXp = .5 * size, bYp = .25 * size, bRp = 0, bRadp = size / 4, cXp = .35 * size, cYp = .5 * size, cRp = 0, cRadp = size / 12, dXp = .65 * size, dYp = .5 * size, dRp = 0, dRadp = size / 12, eXp = .62 * size, eYp = .75 * size, eRp = 2.355, fXp = .38 * size, fYp = .75 * size, fRp = .785, pdotMul = .75, dpdotMul = (pdotMul - 1) / interval, propKey.push(&quot;Composition&quot;), propValue.push(&quot;Lazy Reflections&quot;)), 107 == which &amp;&amp; (aXp = .48 * size, aYp = .55 * size, aRp = 0, bXp = .55 * size, bYp = .5 * size, bRp = 0, bRadp = size / 9, cXp = .675 * size, cYp = .575 * size, cRp = 0, cRadp = size / 14, dXp = .675 * size, dYp = .425 * size, dRp = 0, dRadp = size / 14, eXp = .6 * size, eYp = .39325 * size, eRp = .785, fXp = .6 * size, fYp = .60675 * size, fRp = 2.355, pdotMul = .75, dpdotMul = (pdotMul - 1) / interval, propKey.push(&quot;Composition&quot;), propValue.push(&quot;Reflections&quot;)), 149 == which &amp;&amp; (aXp = .5 * size, aYp = .5 * size, aRp = 1.57, bXp = .5 * size, bYp = .5 * size, bRp = 0, bRadp = size / 5, cXp = .5 * size, cYp = .65 * size, cRp = 0, cRadp = size / 14, dXp = .5 * size, dYp = .35 * size, dRp = 0, dRadp = size / 14, eXp = .5 * size, eYp = .5 * size, eRp = 3.14 * -.2, fXp = .5 * size, fYp = .5 * size, fRp = 3.14 * .2, pdotMul = .75, dpdotMul = (pdotMul - 1) / interval, propKey.push(&quot;Composition&quot;), propValue.push(&quot;Lazy Reflections&quot;)), 173 == which &amp;&amp; (aXp = .25 * size, aYp = .5 * size, aRp = 0, bXp = .5 * size, bYp = .5 * size, bRp = 0, bRadp = size / 6, cXp = .65 * size, cYp = .5 * size, cRp = 0, cRadp = size / 14, dXp = .35 * size, dYp = .5 * size, dRp = 0, dRadp = size / 14, eXp = .5 * size, eYp = .5 * size, eRp = 3.14 * -.2, fXp = .5 * size, fYp = .5 * size, fRp = 3.14 * .2, pdotMul = .75, dpdotMul = (pdotMul - 1) / interval, propKey.push(&quot;Composition&quot;), propValue.push(&quot;Lazy Reflections&quot;)), 211 == which &amp;&amp; (aXp = .5 * size, aYp = .63 * size, aRp = 1.57, bXp = .5 * size, bYp = .45 * size, bRp = 0, bRadp = size / 6, cXp = .6 * size, cYp = .3 * size, cRp = 0, cRadp = size / 14, dXp = .4 * size, dYp = .3 * size, dRp = 0, dRadp = size / 14, eXp = .35 * size, eYp = .5 * size, eRp = 3.14 * -.2, fXp = .65 * size, fYp = .5 * size, fRp = 3.14 * .2, pdotMul = .75, dpdotMul = (pdotMul - 1) / interval, propKey.push(&quot;Composition&quot;), propValue.push(&quot;Lazy Reflections&quot;)), 233 == which &amp;&amp; (aXp = .3 * size, aYp = .4 * size, aRp = 0, bXp = .3 * size, bYp = .65 * size, bRp = 0, bRadp = size / 8, cXp = .5 * size, cYp = .65 * size, cRp = 0, cRadp = size / 14, dXp = .7 * size, dYp = .65 * size, dRp = 0, dRadp = size / 14, eXp = .5 * size, eYp = .4 * size, eRp = 0, fXp = .7 * size, fYp = .4 * size, fRp = 0, pdotMul = .75, dpdotMul = (pdotMul - 1) / interval, propKey.push(&quot;Composition&quot;), propValue.push(&quot;At Attention&quot;)), 277 == which &amp;&amp; (aXp = .4 * size, aYp = .5 * size, aRp = 0, bXp = .425 * size, bYp = .5 * size, bRp = 0, bRadp = size / 5, cXp = .63 * size, cYp = size * (.5 - .218), cRp = 0, cRadp = size / 14, dXp = .63 * size, dYp = .718 * size, dRp = 0, dRadp = size / 14, eXp = .513 * size, eYp = .6 * size, eRp = -.785, fXp = .513 * size, fYp = .4 * size, fRp = .785, pdotMul = .75, dpdotMul = (pdotMul - 1) / interval, propKey.push(&quot;Composition&quot;), propValue.push(&quot;Reflections&quot;)), 313 == which &amp;&amp; (aXp = .625 * size, aYp = .625 * size, aRp = .785, bXp = .425 * size, bYp = .425 * size, bRp = 0, bRadp = size / 8, cXp = .59 * size, cYp = .37 * size, cRp = 0, cRadp = size / 21, dXp = .59 * size, dYp = .48 * size, dRp = 0, dRadp = size / 21, eXp = .4 * size, eYp = .25 * size, eRp = -1.57, fXp = .25 * size, fYp = .4 * size, fRp = 0, pdotMul = 1.25, dpdotMul = (pdotMul - 1) / interval), 349 == which &amp;&amp; (aXp = .3 * size, aYp = .478 * size, aRp = 3.14 * -.2, bXp = .26 * size, bYp = .425 * size, bRp = 0, bRadp = size / 8, cXp = .4 * size, cYp = .62 * size, cRp = 0, cRadp = size / 21, dXp = .4 * size, dYp = .425 * size, dRp = 0, dRadp = size / 21, eXp = .7 * size, eYp = .5 * size, eRp = 0, fXp = .5975 * size, fYp = .478 * size, fRp = 3.14 * .2, pdotMul = 1.25, dpdotMul = (pdotMul - 1) / interval), 367 == which &amp;&amp; (eXp = .325 * size, eYp = .5 * size, eRp = -0, bXp = .325 * size, bYp = .5 * size, bRp = 0, bRadp = size / 6, cXp = .4 * size, cYp = .62 * size, cRp = 0, cRadp = size / 17, dXp = .25 * size, dYp = .38 * size, dRp = 0, dRadp = size / 17, fXp = .6 * size, fYp = size / 2, fRp = HALF_PI / 3, aXp = .6 * size, aYp = size / 2, aRp = HALF_PI / 3 * -1, pdotMul = .75, dpdotMul = (pdotMul - 1) / interval, propKey.push(&quot;Composition&quot;), propValue.push(&quot;Lazy Crossover&quot;)), 383 == which &amp;&amp; (eXp = .2 * size, eYp = size / 2, eRp = PI + 0, bXp = .3 * size, bYp = .4 * size, bRp = 0, bRadp = size / 9, dXp = .5 * size, dYp = .4 * size, dRp = 0, dRadp = size / 18, cXp = .5 * size, cYp = .6 * size, cRp = 0, cRadp = size / 18, fXp = .75 * size, fYp = size / 2, fRp = PI + HALF_PI / 3, aXp = .75 * size, aYp = size / 2, aRp = PI + HALF_PI / 3 * -1, pdotMul = 1.25, dpdotMul = (pdotMul - 1) / interval, propKey.push(&quot;Composition&quot;), propValue.push(&quot;Lazy Crossover&quot;), propKey.push(&quot;Composition&quot;), propValue.push(&quot;Rebound&quot;)), daX = (aXp - aX) / interval, daY = (aYp - aY) / interval, daR = (aRp - aR) / interval, dbX = (bXp - bX) / interval, dbY = (bYp - bY) / interval, dbR = (bRp - bR) / interval, dcX = (cXp - cX) / interval, dcY = (cYp - cY) / interval, dcR = (cRp - cR) / interval, ddX = (dXp - dX) / interval, ddY = (dYp - dY) / interval, ddR = (dRp - dR) / interval, deX = (eXp - eX) / interval, deY = (eYp - eY) / interval, deR = (eRp - eR) / interval, dfX = (fXp - fX) / interval, dfY = (fYp - fY) / interval, dfR = (fRp - fR) / interval, dbRad = (bRadp - bRad) / interval, dcRad = (cRadp - cRad) / interval, ddRad = (dRadp - dRad) / interval, canvas = createGraphics(size, size), canvas.background(0), angleMode(DEGREES), canvas.push(), canvas.clear(), canvas.background(bgcol), canvas.pop(), canvas.stroke(fgcol), canvas.fill(fgcol), canvas.push(), canvas.translate(aX, aY), canvas.rotate(aR), canvas.rect(0 - size / 30 / 2, 0 - size / 3 / 2, size / 30, size / 3), canvas.pop(), canvas.push(), canvas.translate(eX, eY), canvas.rotate(eR), canvas.rect(0 - size / 30 / 2, 0 - size / 3 / 2, size / 30, size / 3), canvas.pop(), canvas.push(), canvas.translate(fX, fY), canvas.rotate(fR), canvas.rect(0 - size / 30 / 2, 0 - size / 3 / 2, size / 30, size / 3), canvas.pop(), canvas.push(), canvas.translate(bX, bY), canvas.rotate(bR), canvas.circle(0, 0, bRad), canvas.pop(), canvas.push(), canvas.translate(cX, cY), canvas.rotate(cR), canvas.circle(0, 0, cRad), canvas.pop(), canvas.push(), canvas.translate(dX, dY), canvas.rotate(dR), canvas.circle(0, 0, dRad), canvas.pop(), stageAdvance = !1, curhue = 15, 1 &lt;= pdotMul ? (propKey.push(&quot;Pulse Direction&quot;), propValue.push(&quot;Contractive&quot;)) : (propKey.push(&quot;Pulse Direction&quot;), propValue.push(&quot;Expansive&quot;)), which % 7 == 0 &amp;&amp; (propKey.push(&quot;Composition&quot;), propValue.push(&quot;b:x&quot;))
}

function mouseClicked() {
     isPaused = !isPaused
}

function draw() {
     isPaused || cFrameCount++, 383 == which &amp;&amp; (curhue &lt; 360 &amp;&amp; cFrameCount % 4 == 0 ? curhue += 1 : cFrameCount % 4 == 0 &amp;&amp; (curhue = 0), colorMode(HSB, 255), thisHueAdjustedCol = color(&quot;hsl(&quot; + curhue + &quot;, 80%, 50%)&quot;), pdotColR = red(thisHueAdjustedCol), pdotColG = green(thisHueAdjustedCol), pdotColB = blue(thisHueAdjustedCol), pdotColA = 255, colorMode(RGB, 255), dpdotColR = (pdotColR - fgcol[0]) / interval, dpdotColG = (pdotColG - fgcol[1]) / interval, dpdotColB = (pdotColB - fgcol[2]) / interval, dpdotColA = (pdotColA - 255) / interval), canvas.push(), canvas.clear(), canvas.background(bgcol), canvas.pop(), canvas.stroke(fgcol), canvas.fill(fgcol);
     let p = int((interval / 2 + cFrameCount) % interval),
          e = (interval / 2 + cFrameCount) % interval;
     e &lt; interval / 4 * 1 ? e *= 4 : e = e &gt;= interval / 4 * 3 ? interval - 4 * (e - (interval / 4 * 3 - 1)) : interval;
     interval, e;
     p == interval - 1 &amp;&amp; (pulses++, pulses % pulseInterval == 0 &amp;&amp; (stageAdvance = !0)), 1 == stageAdvance &amp;&amp; 0 == p &amp;&amp; (itsStage &lt; 3 ? itsStage += 1 : itsStage = 0, 0 == itsStage &amp;&amp; (stageAdvance = !1), 2 == itsStage &amp;&amp; (stageAdvance = !1)), curpdotMul = 1, 2 == itsStage ? (p = 0, pdotCol = [fgcol[0] + e * dpdotColR, fgcol[1] + e * dpdotColG, fgcol[2] + e * dpdotColB, 255 + e * dpdotColA]) : 3 == itsStage ? (p, pdotCol = fgcol, pdotCol = [fgcol[0] + e * dpdotColR, fgcol[1] + e * dpdotColG, fgcol[2] + e * dpdotColB, 255 + e * dpdotColA]) : 0 == itsStage ? (p = interval, pdotCol = [fgcol[0] + e * dpdotColR, fgcol[1] + e * dpdotColG, fgcol[2] + e * dpdotColB, 255 + e * dpdotColA], curpdotMul = 1 + dpdotMul * e) : 1 == itsStage &amp;&amp; (p = interval - p, pdotCol = fgcol, pdotCol = [fgcol[0] + e * dpdotColR, fgcol[1] + e * dpdotColG, fgcol[2] + e * dpdotColB, 255 + e * dpdotColA]), canvas.stroke(pdotCol), canvas.strokeWeight(size / 350), canvas.push(), canvas.push(), canvas.translate(eX + p * deX, eY + p * deY), canvas.rotate(eR + p * deR), canvas.rect(0 - size / 30 / 2, 0 - size / 3 / 2, size / 30, size / 3), canvas.pop(), canvas.push(), canvas.translate(fX + p * dfX, fY + p * dfY), canvas.rotate(fR + p * dfR), canvas.rect(0 - size / 30 / 2, 0 - size / 3 / 2, size / 30, size / 3), canvas.pop(), canvas.push(), canvas.translate(aX + p * daX, aY + p * daY), canvas.rotate(aR + p * daR), canvas.rect(0 - size / 30 / 2, 0 - size / 3 / 2, size / 30, size / 3), canvas.pop(), canvas.push(), canvas.translate(cX + p * dcX, cY + p * dcY), canvas.rotate(cR + p * dcR), canvas.circle(0, 0, curpdotMul * (cRad + p * dcRad)), canvas.pop(), canvas.push(), 383 == which ? 0 == p ? canvas.translate(bX + p * dbX, bY + (interval - e) / interval * 107.75 * (dbY + 4.4)) : canvas.translate(bX + p * dbX, bY + (interval - e) / interval * 112 * (dbY + 4.4)) : which % 7 == 0 ? (tdist = curpdotMul * (bRad + p * dbRad) / 6, 0 == p ? canvas.translate(bX + p * dbX, bY + p * dbY + e / interval * (size / 5)) : canvas.translate(bX + p * dbX, bY + p * dbY)) : canvas.translate(bX + p * dbX, bY + p * dbY), canvas.rotate(bR + p * dbR), canvas.strokeWeight(size / 350), canvas.stroke(color(pdotColR, pdotColG, pdotColB, pdotColA)), canvas.fill(pdotCol), canvas.circle(0, 0, curpdotMul * (bRad + p * dbRad)), canvas.pop(), canvas.push(), canvas.translate(dX + p * ddX, dY + p * ddY), canvas.rotate(dR + p * ddR), canvas.circle(0, 0, curpdotMul * (dRad + p * ddRad)), canvas.pop(), canvas.pop(), image(canvas, 0, 0, outputsize, outputsize)
}

function polygon(e, s, a, p) {
     var i = TWO_PI / p;
     beginShape();
     for (let p = 0; p &lt; TWO_PI; p += i) {
          var o = e + cos(p) * a,
               d = s + sin(p) * a;
          vertex(o, d)
     }
     endShape(CLOSE)
}

function setsize() {
     size = outputsize &lt; 2400 ? 2400 : outputsize + outputsize / 4, halfsize = size / 2, freedom = size / 10
}

function rnd() {
     return seedA ^= seedA &lt;&lt; 13, seedA ^= seedA &gt;&gt; 17, ((seedA ^= seedA &lt;&lt; 5) &lt; 0 ? 1 + ~seedA : seedA) % 1e3 / 1e3
}

function hashInt(p) {
     return A[0] = 0 | p, A[0] -= A[0] &lt;&lt; 6, A[0] ^= A[0] &gt;&gt;&gt; 17, A[0] -= A[0] &lt;&lt; 9, A[0] ^= A[0] &lt;&lt; 4, A[0] -= A[0] &lt;&lt; 3, A[0] ^= A[0] &lt;&lt; 10, A[0] ^= A[0] &gt;&gt;&gt; 15, A[0]
}</pre></body></html>