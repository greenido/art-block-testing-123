<html><body><h1>Name: Dear Hash,</h1><h3>Artist: MODNAR WOLF</h3><h3>Description: A love letter to the beautiful hash behind the art. ⭑･ﾟﾟ･*:༅｡.｡༅:*ﾟ:*:✼:*ﾟ:༅｡.｡༅:*･ﾟﾟ･⭑ (づ￣ ³￣)づ *:･ﾟ✧ 0x... ✧ﾟ･: *</h3><h3>https://modnarwolf.xyz/pages/0x001.html</h3><hr/><p>Script JSON: {&quot;type&quot;:&quot;p5js&quot;,&quot;version&quot;:&quot;1&quot;,&quot;aspectRatio&quot;:&quot;1&quot;}</p><p>Script Type: p5js</p><p>Version: 1</p><p>Script Ratio: 1</p><p>Instructions: </p><p>Hashes Generated per Token: true</p><p>Dynamic Asset? true</p><hr/><p>Artist Ethereum Address: 0x94dd12f273e34fc780538522c6bc63006fd432fb</p><p>Additional Payee: 0x0000000000000000000000000000000000000000</p><p>Additional Payee Percentage: 0</p><p>Price: 0.1</p><p>Currency: ETH</p><p>Currency Address: N/A</p><p>Invocations: 365</p><p>Maximum Invocations: 365</p><p>License: CC BY-NC 4.0</p><p>Token Ids: 49000000,49000001,49000002,49000003,49000004,49000005,49000006,49000007,49000008,49000009,49000010,49000011,49000012,49000013,49000014,49000015,49000016,49000017,49000018,49000019,49000020,49000021,49000022,49000023,49000024,49000025,49000026,49000027,49000028,49000029,49000030,49000031,49000032,49000033,49000034,49000035,49000036,49000037,49000038,49000039,49000040,49000041,49000042,49000043,49000044,49000045,49000046,49000047,49000048,49000049,49000050,49000051,49000052,49000053,49000054,49000055,49000056,49000057,49000058,49000059,49000060,49000061,49000062,49000063,49000064,49000065,49000066,49000067,49000068,49000069,49000070,49000071,49000072,49000073,49000074,49000075,49000076,49000077,49000078,49000079,49000080,49000081,49000082,49000083,49000084,49000085,49000086,49000087,49000088,49000089,49000090,49000091,49000092,49000093,49000094,49000095,49000096,49000097,49000098,49000099</p><p>Active? true</p><p>Paused? false</p><hr/><p><strong>Script:</strong></p><pre>var DEFAULT_SIZE = 800,
     WIDTH = window.innerWidth,
     HEIGHT = window.innerHeight,
     DIM = Math.min(WIDTH, HEIGHT),
     M = DIM / DEFAULT_SIZE;
let cols, rows, oX, oY, canvas = DEFAULT_SIZE * M,
     ttlPnts = 5,
     grdSprSz = 100 * M,
     grdGap = 170 * M;
cols = 4, rows = 4, oX = 80, oY = 80;
let rectCoors = {
     x: [],
     y: []
};

function setGridType(r) {
     switch (r) {
          case 0:
               ttlPnts = Math.round(R.random_between(10, 80)), cols = 2, rows = 2, grdSprSz = 250 * M, grdGap = 400 * M, oX = 80 * M, oY = 80 * M, fontsize = 200 * M, yOff = 175 * M, triSz = 48 * M, sqrSz = 80 * M, cirSz = 80 * M;
               break;
          case 1:
               ttlPnts = 5, cols = 4, rows = 4, grdSprSz = 100 * M, grdGap = 170 * M, oX = 88 * M, oY = 88 * M, fontsize = 72 * M, yOff = 80 * M, triSz = 28 * M, sqrSz = 40 * M, cirSz = 40 * M;
               break;
          case 2:
               ttlPnts = 5, cols = 8, rows = 8, grdSprSz = 70 * M, grdGap = 95 * M, oX = 32 * M, oY = 32 * M, fontsize = 16 * M, yOff = 0, triSz = 14 * M, sqrSz = 20 * M, cirSz = 20 * M
     }
}

function mapRange(r, e, t, s, o) {
     return Math.round(s + (o - s) * (r - e) / (t - e))
}
var hashPairs = [],
     gridHashPairs = [],
     decPairs = [];
let myHash;

function splitHash(r) {
     let e = myHash.length;
     for (let r = 0; r &lt; e; r++)
          for (let e = 0; e &lt; 32; e++) hashPairs.push(myHash[r].slice(2 + 2 * e, 4 + 2 * e))
}

function getDecPairs() {
     return decPairs = hashPairs.map(r =&gt; parseInt(r, 16))
}
myHash = [tokenData.hash];
class Random {
     constructor(r) {
          this.seed = r
     }
     random_dec() {
          return this.seed ^= this.seed &lt;&lt; 13, this.seed ^= this.seed &gt;&gt; 17, this.seed ^= this.seed &lt;&lt; 5, (this.seed &lt; 0 ? 1 + ~this.seed : this.seed) % 1e3 / 1e3
     }
     random_between(r, e) {
          return r + (e - r) * this.random_dec()
     }
     random_int(r, e) {
          return Math.floor(this.random_between(r, e + 1))
     }
     random_choice(r) {
          return r[Math.floor(this.random_between(0, .99 * r.length))]
     }
}
splitHash(), getDecPairs();
let mySeed = parseInt(tokenData.hash.slice(0, 16), 16),
     R = new Random(mySeed);

function getOccurrence(r, e) {
     var t = 0;
     return r.forEach(r =&gt; r === e &amp;&amp; t++), t
}
var gl = {
     tf: !1,
     txt: 155,
     lines: 0,
     bg: 200
};

function setHashTxt(r, e) {
     switch (e) {
          case 0:
               gridHashPairs.push(&quot;0x&quot;, &quot;..&quot;, &quot;..&quot;, myHash[0][64] + myHash[0][65]);
               break;
          case 1:
               gridHashPairs = [&quot;0x&quot;].concat(hashPairs.slice(0, r).concat([&quot;...&quot;]).concat(hashPairs.slice(r + 18, 32)));
               break;
          case 2:
               for (var t = 0; t &lt; myHash[0].length; t++) 0 == t || 1 == t || 64 == t || 65 == t || gridHashPairs.push(myHash[0][t]);
               (gridHashPairs = [&quot;0x&quot;].concat(gridHashPairs)).push(myHash[0][64] + myHash[0][65])
     }
}

function createGrid() {
     for (let t = 0; t &lt; rows; t++)
          for (let s = 0; s &lt; cols; s++) {
               var r = t * grdGap,
                    e = s * grdGap;
               noStroke(), rectCoors.x.push(e + oX), rectCoors.y.push(r + oY)
          }
     hashTxtCreate()
}
let font, fontsize = 72,
     yOff = 80;

function hashTxtCreate() {
     for (let r = 0; r &lt; gridHashPairs.length; r++) drawHashTxt(gridHashPairs[r], rectCoors.x[r], rectCoors.y[r])
}

function drawHashTxt(r, e, t) {
     noStroke(), textSize(fontsize), fill(gl.txt), text(r, e, t + yOff)
}

function getPoints(r, e) {
     let t = {
          x: [],
          y: []
     };
     for (let s = 0; s &lt; ttlPnts; s++) t.x.push(R.random_between(r, r + grdSprSz)), t.y.push(R.random_between(e, e + grdSprSz));
     return t
}
let triSz = 28,
     sqrSz = 40,
     cirSz = 40;
var msgN = !0,
     msgNarr = [];

function createShape(r, e, t) {
     let s;
     switch (strokeJoin(ROUND), 1 == gl.tf ? s = Math.round(R.random_between(3, 6)) : (s = Math.round(R.random_between(0, 6)), msgNarr.push(s)), s) {
          case 0:
               fill(r), ellipse(e, t, cirSz, cirSz);
               break;
          case 1:
               fill(r), triangle(e - triSz, t + triSz, e, t - triSz / 2 - 5, e + triSz, t + triSz);
               break;
          case 2:
               fill(r), rect(e - 15 * M, t - 15 * M, sqrSz, sqrSz);
               break;
          case 3:
               noFill(), ellipse(e, t, cirSz, cirSz);
               break;
          case 4:
               noFill(), triangle(e - triSz, t + triSz, e, t - triSz / 2 - 5 * M, e + triSz, t + triSz);
               break;
          case 5:
               noFill(), rect(e - 15 * M, t - 15 * M, sqrSz, sqrSz)
     }
}
let clrs, c0, c1, c2, c3, c4, c5, c6;

function pkClrs(r) {
     c0 = [color(109, 95, 146), color(216, 145, 177), color(255, 215, 145)], c1 = [color(51, 73, 9), color(170, 200, 112), color(103, 120, 66)], c2 = [color(123, 172, 239), color(255, 254, 252), color(235, 256, 185)], c3 = [color(84, 189, 182), color(230, 220, 171), color(255, 65, 135)], c4 = [color(61, 46, 87), color(26, 73, 143), color(107, 134, 181)], c5 = [color(255, 93, 38), color(234, 50, 84), color(233, 255, 112)], c6 = [color(253, 205, 121), color(213, 96, 76), color(16, 41, 46)], clrs = [c0, c1, c2, c3, c4, c5, c6];
     var e = Math.round(R.random_between(0, 2));
     return clrs[r][e]
}
var cP = Math.round(R.random_between(0, 6));

function drawLine() {
     for (let r = 0; r &lt; rectCoors.x.length; r++) {
          let e = getPoints(rectCoors.x[r], rectCoors.y[r]);
          noStroke();
          for (let r = 0; r &lt; e.x.length; r++) stroke(gl.lines), strokeWeight(3 * M), line(e.x[r - 2], e.y[r - 2], e.x[r], e.y[r]);
          createShape(pkClrs(cP), e.x[0], e.y[0])
     }(getOccurrence(msgNarr, 0) &gt;= 1 || getOccurrence(msgNarr, 1) &gt;= 1 || getOccurrence(msgNarr, 2) &gt;= 1) &amp;&amp; (msgN = !1)
}
var glClr = Math.round(R.random_between(0, 2)),
     gl7 = getOccurrence(decPairs, 7);
let vType = mapRange(decPairs[31], 0, 255, 0, 2);

function setup() {
     if (createCanvas(canvas, canvas), gl7 &gt;= 3) switch (glClr) {
          case 0:
               gl.tf = !0, gl.txt = color(255), gl.lines = color(8), gl.bg = color(224, 25, 49);
               break;
          case 1:
               gl.tf = !0, gl.txt = color(255, 255, 255), gl.lines = color(0, 255, 0), gl.bg = color(0, 0, 0);
               break;
          case 2:
               gl.tf = !0, gl.txt = color(0, 0, 0), gl.lines = color(255, 255, 255), gl.bg = color(255, 168, 0)
     }
     background(gl.bg), setGridType(vType), setHashTxt(mapRange(decPairs[30], 0, 255, 0, 13), vType), createGrid(), drawLine()
}</pre></body></html>