<html>
  <head>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.2.0/p5.js"></script>
    <script>
      // Token Ids: 10000000,10000001,10000002,10000003,10000004,10000005,10000006,10000007,10000008,10000009,10000010,10000011,10000012,10000013,10000014,10000015,10000016,10000017,10000018,10000019,10000020,10000021,10000022,10000023,10000024,10000025,10000026,10000027,10000028,10000029,10000030,10000031,10000032,10000033,10000034,10000035,10000036,10000037,10000038,10000039,10000040,10000041,10000042,10000043,10000044,10000045,10000046,10000047,10000048,10000049,10000050,10000051,10000052,10000053,10000054,10000055,10000056,10000057,10000058,10000059,10000060,10000061,10000062,10000063,10000064,10000065,10000066,10000067,10000068,10000069,10000070,10000071,10000072,10000073,10000074,10000075,10000076,10000077,10000078,10000079,10000080,10000081,10000082,10000083,10000084,10000085,10000086,10000087,10000088,10000089,10000090,10000091,10000092,10000093,10000094,10000095,10000096,10000097,10000098,10000099
      let tokenData = {
        hash:
          "0x2ed5912b84b7777777777772735e5a45416a5a723172a643ca545bee87be96c2",
        //"0x2ed5912b84b45dad487dd392735e5a45416a5a723172a643ca545bee87be96c2", 0x9C238282Db349A20d501c5bfeE13ed29ae5a451C",
        tokenId: "500005"
      };
    </script>
    <style type="text/css">
      body {
        margin: 0;
        padding: 0;
      }

      canvas {
        padding: 0;
        margin: auto;
        display: block;
        position: absolute;
        top: 0;
        bottom: 0;
        left: 0;
        right: 0;
      }
    </style>
  </head>
  <body>
    <center>
      <h1>
        5 üçæ
      </h1>
      <a href="https://api.artblocks.io/project/5">project 5</a>
    </center>
    <script>
      let txnbpointV = 2,
     txnbpointH = 1,
     txnbsegment = "6,7",
     txnbfigure = "2",
     txnbcol = 3,
     txepais = 0,
     txlargeur = 2e3,
     txhauteur = 2e3,
     txnblig = 2,
     txcoltrait = "#BFE2D0",
     txQuadEp = 6,
     txEpaisSurl = 10,
     txDecal = "124,-124",
     txMG = 84,
     txMD = 84,
     txMH = 84,
     txMB = 84,
     txMI = 300,
     txArrondi = 100,
     textarea1 = new Array(73);

function load_textarea1() {
     textarea1[0] = "#080a23*1*1*R**night-blue", textarea1[1] = "#080a23*1*2*R**night-blue", textarea1[2] = "#e0d5ce*1*1*R*CLAIR*off-white", textarea1[3] = "#e0d5ce*1*2*R*CLAIR*off-white", textarea1[4] = "#44ffb900-#440fc4a0*3**FDH**", textarea1[5] = "#44ffb900-#440fc4a0*3**FDV**", textarea1[6] = "#440fc4a0-#44ffb900*3**FDH**", textarea1[7] = "#440fc4a0-#44ffb900*3**FDV**", textarea1[8] = "#44e27824-#4423084b*3**FDH**", textarea1[9] = "#44e27824-#4423084b*3**FDV**", textarea1[10] = "#4423084b-#44e27824*3**FDH**", textarea1[11] = "#4423084b-#44e27824*3**FDV**", textarea1[13] = "#4b4148-#080a23*1**FDV*FFONCE*", textarea1[14] = "#00ff00*1**Q*FFONCE*", textarea1[12] = "#fffc8a-#fff000*1**FDV**", textarea1[15] = "#ffffff*1*1*S**", textarea1[16] = "#ffffff*1*2*S**", textarea1[17] = "#080a23*1*1*S*CLAIR*", textarea1[18] = "#080a23*1*2*S*CLAIR*", textarea1[19] = "#B3ffffff*1**Q**", textarea1[20] = "#4D080a23*1**Q**", textarea1[21] = "#b14254-#355c7a*1**MDH**", textarea1[22] = "#b14254-#355c7a*1**MDV**", textarea1[23] = "#355c7a-#b14254*1**MDH**", textarea1[24] = "#355c7a-#b14254*1**MDV**", textarea1[25] = "#590c3877-#5900b290*2**MDH**", textarea1[26] = "#590c3877-#5900b290*2**MDV**", textarea1[27] = "#5900b290-#590c3877*2**MDH**", textarea1[28] = "#5900b290-#590c3877*2**MDV**", textarea1[29] = "#ffe888-#54b5a3*1**MDH**", textarea1[30] = "#ffe888-#54b5a3*1**MDV**", textarea1[31] = "#54b5a3-#ffe888*1**MDH**", textarea1[32] = "#54b5a3-#ffe888*1**MDV**", textarea1[33] = "#59cd924a-#5954b5a3*2**MDH**", textarea1[34] = "#59cd924a-#5954b5a3*2**MDV**", textarea1[35] = "#5954b5a3-#59cd924a*2**MDH**", textarea1[36] = "#5954b5a3-#59cd924a*2**MDV**", textarea1[37] = "#BFe27824-#23084b*1**MDV**", textarea1[38] = "#BFe27824-#23084b*1**MDH**", textarea1[39] = "#23084b-#BFe27824*1**MDV**", textarea1[40] = "#23084b-#BFe27824*1**MDH**", textarea1[41] = "#59e27824-#5923084b*2**MDV**", textarea1[42] = "#59e27824-#5923084b*2**MDH**", textarea1[43] = "#5923084b-#59e27824*2**MDV**", textarea1[44] = "#5923084b-#59e27824*2**MDH**", textarea1[45] = "#9ab18a-#9a365d*1**MDV**", textarea1[46] = "#9a365d-#9ab18a*1**MDH**", textarea1[47] = "#9a365d-#9ab18a*1**MDV**", textarea1[48] = "#9ab18a-#9a365d*1**MDH**", textarea1[49] = "#599ab18a-#599a365d*2**MDV**", textarea1[50] = "#599a365d-#599ab18a*2**MDH**", textarea1[51] = "#599a365d-#599ab18a*2**MDV**", textarea1[52] = "#599ab18a-#599a365d*2**MDH**", textarea1[53] = "#BFe27824-#23084b*1**MDV*CLAIR*", textarea1[54] = "#BFe27824-#23084b*1**MDH*CLAIR*", textarea1[55] = "#23084b-#BFe27824*1**MDV*CLAIR*", textarea1[56] = "#23084b-#BFe27824*1**MDH*CLAIR*", textarea1[57] = "#6d1e3a-#984527*1**MDV*CLAIR*", textarea1[58] = "#984527-#6d1e3a*1**MDH*CLAIR*", textarea1[59] = "#984527-#6d1e3a*1**MDV*CLAIR*", textarea1[60] = "#6d1e3a-#984527*1**MDH*CLAIR*", textarea1[61] = "#17062d-#6d1e37*1**MDV*CLAIR*", textarea1[62] = "#6d1e37-#17062d*1**MDH*CLAIR*", textarea1[63] = "#6d1e37-#17062d*1**MDV*CLAIR*", textarea1[64] = "#17062d-#6d1e37*1**MDH*CLAIR*", textarea1[65] = "#1f4056-#080a23*1**MDV*CLAIR*", textarea1[66] = "#1f4056-#080a23*1**MDH*CLAIR*", textarea1[67] = "#080a23-#1f4056*1**MDV*CLAIR*", textarea1[68] = "#080a23-#1f4056*1**MDH*CLAIR*", textarea1[69] = "#684949-#3e4952*1**MDV*CLAIR*", textarea1[70] = "#684949-#3e4952*1**MDH*CLAIR*", textarea1[71] = "#3e4952-#684949*1**MDV*CLAIR*", textarea1[72] = "#3e4952-#684949*1**MDH*CLAIR*"
}
class Random {
     constructor(e) {
          this.seed = e
     }
     random_dec() {
          return this.seed ^= this.seed << 13, this.seed ^= this.seed >> 17, this.seed ^= this.seed << 5, (this.seed < 0 ? 1 + ~this.seed : this.seed) % 1e3 / 1e3
     }
     random_between(e, t) {
          return e + (t - e) * this.random_dec()
     }
     random_int(e, t) {
          return Math.floor(this.random_between(e, t + 1))
     }
     random_choice(e) {
          return e[Math.floor(this.random_between(0, .99 * e.length))]
     }
}
let seed = parseInt(tokenData.hash.slice(0, 16), 16),
     R = new Random(seed),
     done = !1,
     couleurs_surlig = new Array(0),
     couleurs_marge = new Array(0),
     couleurs_quad = new Array(0),
     couleurs_remp = new Array(0),
     couleurs_trait = new Array(0),
     couleurs_fond = new Array(0),
     grpcouleurs = new Array(0),
     degCold = 0,
     degColf = 0,
     degrad = "",
     ok = !1,
     numOrd = 0,
     pash = 0,
     pasl = 0,
     pointsx = new Array(0),
     pointsy = new Array(0),
     nordres = new Array(0),
     nordre = 0,
     xpoint = 0,
     ypoint = 0,
     M = 0,
     grRetour = "";

function setup() {
     var e = txhauteur + txMH + txMB + 2 * txMI,
          t = window.innerWidth,
          r = window.innerHeight,
          a = Math.min(t, r);
     M = a / e, txlargeur = int(M * txlargeur), txhauteur = int(M * txhauteur), txMD = int(M * txMD), txMG = int(M * txMG), txMH = int(M * txMH), txMB = int(M * txMB), txMI = int(M * txMI), txArrondi = int(M * txArrondi), txepais *= M, txEpaisSurl *= M, txQuadEp *= M, load_textarea1(), createCanvas(txlargeur + txMD + txMG + 2 * txMI, txhauteur + txMH + txMB + 2 * txMI, P2D), noLoop()
}

function draw() {
     if (1 == done);
     else {
          done = !0;
          let e = int(R.random_between(0, 100));
          grpcouleurs[0] = e <= 90 ? "" : "CLAIR";
          let t = color("#fff5e1");
          background(t), smooth(), noStroke(), pash = txhauteur / txnblig, pasl = txlargeur / txnbcol, colorMode(RGB);
          let r = split(trim(txnbfigure), ","),
               a = r[0],
               n = split(trim(txnbsegment), ","),
               o = n[0],
               l = txMI,
               x = "0";
          x = "0";
          let u = "";
          for (let e = 0; e < textarea1.length; e += 1) {
               let t = split(textarea1[e], "*"),
                    r = int(t[1]);
               for (u = t[3].toUpperCase(); r > 0;) {
                    switch (u) {
                         case "":
                              couleurs_marge.push(textarea1[e]), couleurs_quad.push(textarea1[e]), couleurs_trait.push(textarea1[e]), couleurs_surlig.push(textarea1[e]), couleurs_remp.push(textarea1[e]), couleurs_fond.push(textarea1[e]);
                              break;
                         case "M":
                         case "MDH":
                         case "MDV":
                              couleurs_marge.push(textarea1[e]);
                              break;
                         case "Q":
                              couleurs_quad.push(textarea1[e]);
                              break;
                         case "T":
                              couleurs_trait.push(textarea1[e]);
                              break;
                         case "S":
                              couleurs_surlig.push(textarea1[e]);
                              break;
                         case "R":
                              couleurs_remp.push(textarea1[e]);
                              break;
                         case "F":
                         case "FDH":
                         case "FDV":
                              couleurs_fond.push(textarea1[e])
                    }
                    r -= 1
               }
          }
          couleurs_marge = scramble(couleurs_marge), couleurs_quad = scramble(couleurs_quad), couleurs_trait = scramble(couleurs_trait), couleurs_surlig = scramble(couleurs_surlig), couleurs_remp = scramble(couleurs_remp), couleurs_fond = scramble(couleurs_fond), noStroke();
          let s = txlargeur + 2 * txMI,
               i = txhauteur + 2 * txMI,
               d = 0,
               c = int(R.random_between(0, couleurs_marge.length));
          d = getCouleurs(c, 999, !0, "M", grpcouleurs[0]), "V" == degrad || "H" == degrad ? (coldegrad(txMG, txMH, s, i, txArrondi, degrad), noFill()) : fill(d);
          let b = round(txArrondi / 3 + 1);
          strokeWeight(b), stroke(t), mod = rect(txMG - b / 2, txMH - b / 2, s + b, i + b, txArrondi), noStroke(), blendMode(BLEND);
          let p = int(split(trim(txDecal), ",")),
               f = txMG + txMI,
               g = txMH + txMI,
               h = txlargeur,
               D = txhauteur,
               H = h / txnbcol,
               _ = D / txnblig,
               A = getCouleurs(c = int(R.random_between(0, couleurs_fond.length)), 999, !1, "F", grpcouleurs[0]);
          grpcouleurs[1] = grRetour, "V" == degrad || "H" == degrad ? (coldegrad(f, g, h, D, 0, degrad), noFill()) : fill(A), mod = rect(f, g, h, D);
          let m = new Array(0),
               C = new Array(0);
          for (let e = 0; e < txnbcol + 1; e += 1) m.push(e * pasl);
          for (let e = 0; e < txnblig + 1; e += 1) C.push(e * pash);
          quadri(m, C, f, g, H, _);
          let I = new Array(0),
               V = new Array(0),
               w = new Array(0),
               k = new Array(0);
          nordre = 0, xpoint = pasl / (txnbpointH + 1), ypoint = pash / (txnbpointV + 1);
          for (let e = 0; e < txnbpointH + 2; e += 1) {
               appendXY(e, 0, txnbpointH + 1, txnbpointV + 1)
          }
          for (let e = 0; e < txnbpointV + 2; e += 1) {
               appendXY(txnbpointH + 1, e, txnbpointH + 1, txnbpointV + 1)
          }
          for (let e = txnbpointH + 1; e > -1; e -= 1) {
               appendXY(e, txnbpointV + 1, txnbpointH + 1, txnbpointV + 1)
          }
          for (let e = txnbpointV + 1; e >= 0; e -= 1) {
               appendXY(0, e, txnbpointH + 1, txnbpointV + 1)
          }
          strokeCap(ROUND), strokeJoin(ROUND), a = r[int(R.random_between(0, r.length))];
          for (let e = 0; e < a; e += 1) {
               blendMode(BLEND), txMI = l, e < p.length && (txMI += p[e] * M), V = new Array(0), w = new Array(0), k = new Array(0);
               for (let t = 0; t < txnbcol; t += 1)
                    for (let r = 0; r < txnblig; r += 1) {
                         let a = int(R.random_between(couleurs_remp.length));
                         if (fill(getCouleurs(a, e, !0, "R", grpcouleurs[0])), 0 != txepais) {
                              let e = traiteCouleurs(txcoltrait);
                              stroke(e), strokeWeight(txepais)
                         }
                         nordres = scramble(nordres), I = new Array(0), o = n[int(R.random_between(0, n.length))];
                         for (let e = 0; e < int(o) + 1; e += 1) I.push(nordres[e]);
                         I.sort(function(e, t) {
                              return e - t
                         }), beginShape();
                         let l = o;
                         k.push(l);
                         for (let e = 0; e < l; e += 1) {
                              let a = pointsx[I[e]],
                                   n = pointsy[I[e]],
                                   o = int(a + txMG + txMI + m[t]),
                                   l = int(n + txMH + txMI + C[r]);
                              vertex(o, l), V.push(o), w.push(l)
                         }
                         endShape(CLOSE)
                    }
               surligner(V, w, k, e), V = new Array(0), w = new Array(0), k = new Array(0)
          }
     }
}

function appendXY(e, t, r, a) {
     e == r ? pointsx.push(pasl) : pointsx.push(e * xpoint), t == a ? pointsy.push(pash) : pointsy.push(t * ypoint), nordres.push(nordre), nordre += 1
}

function scramble(e) {
     let t = [],
          r = e.length;
     for (let a = 0; a < r; a++) {
          let r = floor(map(R.random_dec(), 0, 1, 0, e.length));
          t.push(e[r]), e.splice(r, 1)
     }
     return t
}

function surligner(e, t, r, a) {
     strokeWeight(txEpaisSurl);
     let n = 0,
          o = 0,
          l = 0;
     a -= 1;
     let x = 0;
     for (let u = 0; u < e.length; u += 1) {
          let s = e[u],
               i = t[u],
               d = 0;
          o == l ? (l = r[n], d = u + int(l) - 1, n % (txnbcol * txnblig) == 0 && (x = getCouleurs(0, a += 1, !0, "S", grpcouleurs[0])), n += 1, o = 0) : d = u - 1, o += 1;
          let c = e[d],
               b = t[d];
          c != s && b != i && ok && (stroke(x), line(c, b, s, i))
     }
     noStroke()
}

function quadri(e, t, r, a, n, o) {
     let l = getCouleurs(int(R.random_between(0, couleurs_quad.length)), 999, !0, "Q", grpcouleurs[1]);
     stroke(l), strokeWeight(txQuadEp);
     let x = n / (int(txnbpointH) + 1),
          u = o / (int(txnbpointV) + 1),
          s = t[txnblig] + txMH + txMI,
          i = e[txnbcol] + txMG + txMI,
          d = a,
          c = r;
     for (let e = 1; e < txnbcol * (int(txnbpointH) + 1); e += 1) line(r + e * x, d, r + e * x, s);
     line(r, a, r, t[txnblig] + txMH + txMI), line(e[txnbcol] + txMG + txMI, a, e[txnbcol] + txMG + txMI, t[txnblig] + txMH + txMI);
     for (let e = 1; e < txnblig * (int(txnbpointV) + 1); e += 1) line(c, a + e * u, i, a + e * u);
     line(r, a, e[txnbcol] + txMG + txMI, a), line(r, t[txnblig] + txMH + txMI, e[txnbcol] + txMG + txMI, t[txnblig] + txMH + txMI), noStroke()
}

function traiteCouleurs(e) {
     let t = 0,
          r = splitTokens(e, ", ");
     switch (r.length) {
          case 1:
               if ("#" == r[0].substring(0, 1)) {
                    if (7 == r[0].length) {
                         let e = unhex(r[0].substring(1, 3)),
                              a = unhex(r[0].substring(3, 5)),
                              n = unhex(r[0].substring(5));
                         t = color(e, a, n)
                    }
                    if (9 == r[0].length) {
                         let e = unhex(r[0].substring(1, 3)),
                              a = unhex(r[0].substring(3, 5)),
                              n = unhex(r[0].substring(5, 7)),
                              o = unhex(r[0].substring(7));
                         t = color(a, n, o, e)
                    }
               } else t = int(r[0]);
               break;
          case 2:
               t = color(int(r[0]), int(r[1]));
               break;
          case 3:
               t = color(int(r[0]), int(r[1]), int(r[2]));
               break;
          case 4:
               t = color(int(r[0]), int(r[1]), int(r[2]), int(r[3]))
     }
     return t
}

function getCouleurs(e, t, r, a, n) {
     let o = new Array(0);
     switch (a) {
          case "M":
               o = couleurs_marge.copyWithin(0);
               break;
          case "Q":
               o = couleurs_quad.copyWithin(0);
               break;
          case "T":
               o = couleurs_trait.copyWithin(0);
               break;
          case "S":
               o = couleurs_surlig.copyWithin(0);
               break;
          case "R":
               o = couleurs_remp.copyWithin(0);
               break;
          case "F":
               o = couleurs_fond.copyWithin(0)
     }
     degrad = "";
     let l, x = !1,
          u = !1,
          s = 0,
          i = "";
     for (; 0 == x;) i = e + s < o.length ? o[e + s] : o[0], l = split(i, "*"), 0 == r ? (x = !0, ok = !0) : int(l[2]) != t + 1 && 999 != t || l[4] == n && (ok = !0, x = !0), e + s < o.length - 1 ? s += 1 : (1 == u && (x = !0, ok = !0), s = 0 - e, u = !0);
     grRetour = l[4];
     let d = l[0],
          c = 0,
          b = split(d, "-");
     if (void 0 === b[1]) c = traiteCouleurs(b[0]);
     else {
          c = color(255, 255, 255);
          let e = traiteCouleurs(b[0]),
               t = traiteCouleurs(b[1]);
          if ("DV" == l[3].substring(1) || "DH" == l[3].substring(1)) degCold = e, degColf = t, degrad = l[3].substring(2);
          else {
               let r = R.random_between(0, 100) / 100;
               c = lerpColor(e, t, r)
          }
     }
     return c
}

function coldegrad(e, t, r, a, n, o) {
     if (e = round(e), t = round(t), r = round(r), a = round(a), n = round(n), beginShape(), noStroke(), "V" == o)
          for (let n = 0; n < a; n += 1) {
               let o = map(n, 0, a, 0, 1),
                    l = lerpColor(degCold, degColf, o);
               fill(l), rect(e, n + t, r, 1)
          } else
               for (let n = 0; n < r; n += 1) {
                    let o = map(n, 0, r, 0, 1),
                         l = lerpColor(degCold, degColf, o);
                    fill(l), rect(n + e, t, 1, a)
               }
     endShape()
}
    </script>
  </body>
</html>
