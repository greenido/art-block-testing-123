<html><body><h1>Name: Paper Armada</h1><h3>Artist: Kjetil Golid</h3><h3>Description: Perfectly symmetric - imperfectly drawn. Exploring the contrast between precision and chance in a playful spacecraft / papercraft setting. </h3><h3>https://generated.space</h3><hr/><p>Script JSON: {&quot;type&quot;:&quot;js&quot;,&quot;version&quot;:&quot;1&quot;,&quot;aspectRatio&quot;:&quot;1&quot;,&quot;curation_status&quot;:&quot;playground&quot;}</p><p>Script Type: js</p><p>Version: 1</p><p>Script Ratio: 1</p><p>Instructions: </p><p>Hashes Generated per Token: true</p><p>Dynamic Asset? true</p><hr/><p>Artist Ethereum Address: 0x08f950816358f4306b70fb319e4f35c592d1b8a8</p><p>Additional Payee: 0x0000000000000000000000000000000000000000</p><p>Additional Payee Percentage: 0</p><p>Price: 0.1</p><p>Currency: ETH</p><p>Currency Address: N/A</p><p>Invocations: 3000</p><p>Maximum Invocations: 3000</p><p>License: NIFTY License</p><p>Token Ids: 37000000,37000001,37000002,37000003,37000004,37000005,37000006,37000007,37000008,37000009,37000010,37000011,37000012,37000013,37000014,37000015,37000016,37000017,37000018,37000019,37000020,37000021,37000022,37000023,37000024,37000025,37000026,37000027,37000028,37000029,37000030,37000031,37000032,37000033,37000034,37000035,37000036,37000037,37000038,37000039,37000040,37000041,37000042,37000043,37000044,37000045,37000046,37000047,37000048,37000049,37000050,37000051,37000052,37000053,37000054,37000055,37000056,37000057,37000058,37000059,37000060,37000061,37000062,37000063,37000064,37000065,37000066,37000067,37000068,37000069,37000070,37000071,37000072,37000073,37000074,37000075,37000076,37000077,37000078,37000079,37000080,37000081,37000082,37000083,37000084,37000085,37000086,37000087,37000088,37000089,37000090,37000091,37000092,37000093,37000094,37000095,37000096,37000097,37000098,37000099</p><p>Active? true</p><p>Paused? false</p><hr/><p><strong>Script:</strong></p><pre>let seed = generateSeedFromTokenData(tokenData);
const rng = rnd;
let scale, baseVector;
window.onload = function() {
     var e = document.createElement(&quot;canvas&quot;);
     const n = 4 * Math.min(window.innerWidth, window.innerHeight);
     if (e.width = n, e.height = n, e.setAttribute(&quot;style&quot;, &quot;width:&quot; + n / 4 + &quot;px; height:&quot; + n / 4 + &quot;px;&quot;), scale = n / 1e3, document.body.appendChild(e), e.getContext) {
          var t = e.getContext(&quot;2d&quot;);
          const n = w_pick([{
               u1: -.04,
               u2: .38
          }, {
               u1: 1.04,
               u2: .62
          }, {
               u1: -.1,
               u2: .4
          }, {
               u1: 1.1,
               u2: .6
          }, {
               u1: 0,
               u2: .5
          }], [16, 8, 4, 2, 1]);
          baseVector = {
               u1: [Math.cos(n.u1 * Math.PI), Math.sin(n.u1 * Math.PI)],
               u2: [Math.cos(n.u2 * Math.PI), Math.sin(n.u2 * Math.PI)]
          };
          const l = w_pick([0, 1, 2, 3, 4, 5], [60, 15, 15, 6, 3, 1]),
               a = get_palette(),
               s = w_pick([&quot;random&quot;, &quot;group&quot;, &quot;main&quot;, &quot;single&quot;], [4, 16, 4, 1]),
               u = w_pick([!0, !1], [1, 4]),
               h = w_pick([!0, !1], 0 == l || 5 === l ? [1, 9] : [9, 1]),
               f = w_pick([!0, !1], [1, 19]),
               p = w_pick([.2, .5, .75], [1, 4, 1]),
               g = [{
                    name: &quot;trooper&quot;,
                    rows: 1,
                    columns: 3,
                    pad_x: 38,
                    cell_size: 18,
                    radius_x: pick([12, 14, 16]),
                    radius_y: pick([16, 18, 20, 22]),
                    block_size: .78,
                    equal_rows: !1,
                    double: !1
               }, {
                    name: &quot;convoy&quot;,
                    rows: 1,
                    columns: 2,
                    pad_x: 45,
                    pad_y: 25,
                    radius_x: 10,
                    radius_y: 24,
                    double: !0,
                    rows2: 1,
                    columns2: 1,
                    radius_x2: 6,
                    radius_y2: 12,
                    block_size2: .72
               }, {
                    name: &quot;carrier&quot;,
                    rows: 2,
                    columns: pick([2, 3, 4]),
                    pad_x: 15,
                    pad_y: 50,
                    radius_x: 5,
                    radius_y: 8,
                    block_size: .72,
                    double: !0,
                    rows2: 1,
                    columns2: 1,
                    radius_x2: 26,
                    radius_y2: 10
               }, {
                    name: &quot;cruiser&quot;,
                    rows: pick([2, 3]),
                    columns: 2,
                    pad_x: 55,
                    pad_y: 25,
                    radius_x: 6,
                    radius_y: 8,
                    block_size: .72,
                    double: !0,
                    rows2: 1,
                    columns2: 1,
                    radius_x2: 14,
                    radius_y2: 30
               }, {
                    name: &quot;mothership&quot;,
                    radius_x: 36,
                    radius_y: 28,
                    double: !1
               }, {
                    name: &quot;swarm&quot;,
                    rows: 7,
                    columns: 7,
                    pad_x: 16,
                    pad_x: 16,
                    cell_size: 12,
                    radius_x: 5,
                    radius_y: 5,
                    block_size: .68,
                    double: !1
               }][l];
          let m = {
               rows: g.rows || 1,
               columns: g.columns || 1,
               padding_x: g.pad_x || 20,
               padding_y: g.pad_y || 20,
               cell_size: g.cell_size || 16,
               cell_pad: -2,
               radius_x: g.radius_x,
               radius_y: g.radius_y,
               h_symmetric: !0,
               v_symmetric: f,
               simple: !1,
               roundness: 0,
               solidness: pick([.5, .8, 1]),
               compactness: 1,
               block_size: g.block_size || .8,
               chance_vertical: p,
               display_fill: !0,
               palette: a,
               color_mode: s,
               group_size: .65,
               use_simplex: !1,
               rate_of_change: .05,
               equal_rows: h,
               ethereal: u
          };
          var o = {
               ...m,
               radius_x: g.radius_x2,
               radius_y: g.radius_y2,
               rows: g.rows2 || 1,
               columns: g.columns2 || 1,
               block_size: g.block_size2 || .8
          };
          const b = i(c(m), m.equal_rows, m.columns, m.rows),
               w = g.double ? i(c(o), o.equal_rows, o.columns, o.rows) : null;
          ! function(n, t, o) {
               let c = o * scale,
                    i = e.width,
                    l = e.height;
               n.clearRect(0, 0, i, l), n.fillStyle = t, n.globalAlpha = 1, n.fillRect(0, 0, i, l);
               const r = 10 * c,
                    a = [i / 2, l / 2],
                    s = [];
               for (var u = -20; u &lt;= 20; u++) {
                    n.beginPath();
                    var h = d(a[0] + u * r, -l),
                         f = d(a[0] + u * r, 2 * l);
                    s.push(roughLine(h, f, 4 * o))
               }
               for (var u = -20; u &lt;= 20; u++) {
                    n.beginPath();
                    var h = d(2 * -i, a[1] + u * r),
                         f = d(2 * i, a[1] + u * r);
                    s.push(roughLine(h, f, 4 * o))
               }
               n.lineCap = &quot;square&quot;, n.lineWidth = 2 * scale, n.globalAlpha = .2, s.forEach(e =&gt; _(n, e, null, &quot;#fff&quot;, !1))
          }(t, m.palette.b, m.cell_size + m.cell_pad),
          function(n, t) {
               let o = e.width,
                    c = e.height;
               n.beginPath(), n.moveTo(0, 0), n.lineTo(o, 0), n.lineTo(o, c), n.lineTo(0, c), n.lineTo(0, 0), n.closePath(), n.moveTo(t, t), n.lineTo(t, c - t), n.lineTo(o - t, c - t), n.lineTo(o - t, t), n.lineTo(t, t), n.closePath(), n.fillStyle = &quot;#000&quot;, n.globalAlpha = 1, n.fill()
          }(t, 25 * scale), r(t, b, m), g.double &amp;&amp; r(t, w, o)
     }

     function c(e) {
          let n = {
               initiate_chance: e.compactness,
               extension_chance: e.block_size,
               vertical_chance: e.chance_vertical,
               horizontal_symmetry: e.h_symmetric,
               vertical_symmetry: e.v_symmetric,
               simple: e.simple,
               roundness: e.roundness,
               solidness: e.solidness,
               colors: e.palette.c,
               color_mode: e.color_mode,
               group_size: e.group_size,
               rng: rng
          };
          return new Apparatus(e.radius_x, e.radius_y, n)
     }

     function i(e, n, t, o) {
          let c, i = [];
          for (let r = 0; r &lt; o; r++) {
               let o = [];
               n &amp;&amp; (c = e.generate(null, null, !1, r, 0));
               for (let i = 0; i &lt; t; i++) n || (c = e.generate(null, null, !1, r * t + i, 0)), o.push(c.map(l));
               i.push(o)
          }
          return i
     }

     function l(e) {
          const n = rng();
          return {
               ...e,
               shade: n &lt; .3 ? -1 : n &lt; .7 ? 0 : 1,
               col: rng() &lt; .001 ? pick(get_palette().c) : e.col
          }
     }

     function r(n, t, o) {
          let c = o.padding_x,
               i = o.padding_y,
               l = o.columns,
               r = o.rows;
          const s = e.height / 2;
          n.save(), n.translate(s, s);
          var u = (o.cell_size + o.cell_pad) * scale,
               _ = [c * (l - 1) / 2 * u, i * (r - 1) / 2 * u],
               h = d(c, 0),
               f = d(0, i);
          for (let e = 0; e &lt; r; e++) {
               n.save();
               for (let c = 0; c &lt; l; c++) n.lineCap = &quot;square&quot;, n.lineWidth = 1.5 * scale, a(n, t[e][c], o, _), n.translate(h[0] * u, h[1] * u);
               n.restore(), n.translate(f[0] * u, f[1] * u)
          }
          n.restore()
     }

     function a(e, n, t, o) {
          e.save();
          const {
               cell_size: c,
               cell_pad: i,
               display_fill: l,
               ethereal: r,
               v_symmetric: a
          } = t;
          var d = (c + i) * scale;
          let h = function(e) {
               const n = 2 * e.radius_x + 11,
                    t = 2 * e.radius_y + 11;
               return [n + 2, t + 2]
          }(t);
          const f = n.map(e =&gt; {
               const n = u(e.x1, e.y1, h, a);
               return {
                    ...e,
                    points: s(n[0] * d - o[0], n[1] * d - o[1], e.w * d - i * scale, e.h * d - i * scale),
                    shade_mid_points: s(n[0] * d - o[0] - 4 * scale, n[1] * d - o[1] - 4 * scale, e.w * d - (i - 8) * scale, e.h * d - (i - 8) * scale),
                    shade_points: s((n[0] - .8) * d - o[0], (n[1] + 1) * d - o[1], e.w * d - i * scale, e.h * d - i * scale)
               }
          });
          l &amp;&amp; (e.globalCompositeOperation = &quot;normal&quot;, e.globalAlpha = 1, f.forEach(n =&gt; {
               _(e, n.shade_points, &quot;#000&quot;, null, !1)
          }), f.forEach(n =&gt; {
               _(e, n.shade_mid_points, r ? &quot;#000&quot; : &quot;#fff&quot;, null, !1)
          }), e.globalCompositeOperation = r ? &quot;screen&quot; : &quot;multiply&quot;, f.forEach(n =&gt; {
               _(e, n.points, n.col, null, !0)
          })), e.globalCompositeOperation = &quot;overlay&quot;, e.globalAlpha = .2, f.forEach(n =&gt; {
               if (0 !== n.shade) {
                    const t = u(n.x1, n.y1, h, a),
                         c = s(t[0] * d - o[0], t[1] * d - o[1], n.w * d - i, n.h * d - i);
                    e.lineCap = &quot;round&quot;, _(e, c, 1 === n.shade ? &quot;#fff&quot; : &quot;#000&quot;, null, !1)
               }
          }), e.restore()
     }

     function s(e, n, t, o) {
          const c = d(e, n),
               i = d(e + t, n),
               l = d(e + t, n + o),
               r = d(e, n + o);
          return [...roughLine(c, i), ...roughLine(i, l), ...roughLine(l, r), ...roughLine(r, c)]
     }

     function d(e, n) {
          var t = baseVector.u1,
               o = baseVector.u2;
          return [e * t[0] + n * o[0], e * t[1] + n * o[1]]
     }

     function u(e, n, t, o) {
          return [e - t[0] / 2, n - (o ? t[1] / 2 : 6 * t[1] / 11)]
     }

     function _(e, n, t, o, c) {
          e.beginPath(), e.moveTo(n[0].a[0], n[0].a[1]);
          for (let t = 1; t &lt; n.length; t++) {
               let o = n[t - 1],
                    c = n[t];
               e.bezierCurveTo(o.cp2 ? o.cp2[0] : o.a[0], o.cp2 ? o.cp2[1] : o.a[1], c.cp1 ? c.cp1[0] : c.a[0], c.cp1 ? c.cp1[1] : c.a[1], c.a[0], c.a[1])
          }
          null != t &amp;&amp; (e.fillStyle = t, e.fill()), null != o &amp;&amp; (e.strokeStyle = o, e.stroke())
     }
};
class Apparatus {
     constructor(e, n, {
          initiate_chance: t = .8,
          extension_chance: o = .8,
          vertical_chance: c = .8,
          horizontal_symmetry: i = !0,
          vertical_symmetry: l = !1,
          roundness: r = .1,
          solidness: a = .5,
          colors: s = [],
          color_mode: d = &quot;group&quot;,
          group_size: u = .8,
          simple: _ = !1,
          simplex: h = null,
          rate_of_change: f = .01,
          rng: p = null
     } = {}) {
          this.xdim = Math.round(2 * e + 11, 0), this.ydim = Math.round(2 * n + 11, 0), this.radius_x = e, this.radius_y = n, this.chance_new = t, this.chance_extend = o, this.chance_vertical = c, this.colors = s, this.color_mode = d, this.group_size = u, this.h_symmetric = i, this.v_symmetric = l, this.roundness = r, this.solidness = a, this.simple = _, this.simplex = h, this.rate_of_change = f, this.rng = p
     }
     generate(e = null, n = null, t = !1, o = 0, c = 0) {
          this.idx = o, this.idy = c, this.main_color = this.get_random(this.colors), this.id_counter = 0;
          let i = new Array(this.ydim + 1);
          for (var l = 0; l &lt; i.length; l++) {
               i[l] = new Array(this.xdim + 1);
               for (var r = 0; r &lt; i[l].length; r++) 0 == l || 0 == r ? i[l][r] = {
                    h: !1,
                    v: !1,
                    in: !1,
                    col: null
               } : 1 == l &amp;&amp; null != e ? i[l][r] = {
                    ...e[r],
                    h: !0
               } : 1 == r &amp;&amp; null != n ? i[l][r] = {
                    ...n[l],
                    v: !0
               } : this.h_symmetric &amp;&amp; r &gt; i[l].length / 2 ? (i[l][r] = deep_copy(i[l][i[l].length - r]), i[l][r].v = i[l][i[l].length - r + 1].v) : this.v_symmetric &amp;&amp; l &gt; i.length / 2 ? (i[l][r] = deep_copy(i[i.length - l][r]), i[l][r].h = i[i.length - l + 1][r].h) : i[l][r] = this.next_block(r, l, i[l][r - 1], i[l - 1][r])
          }
          let a = convert_linegrid_to_rectangles(i);
          return t ? [a, i] : a
     }
     next_block(e, n, t, o) {
          const c = this;
          if (!t.in &amp;&amp; !o.in) return function(e, n) {
               return a(e, n) ? r() : {
                    v: !1,
                    h: !1,
                    in: !1,
                    col: null,
                    id: null
               }
          }(e, n);
          if (t.in &amp;&amp; !o.in) return t.h ? function(e, n) {
               return d(e, n) ? {
                    v: !1,
                    h: !0,
                    in: !0,
                    col: t.col,
                    id: t.id
               } : i(e, n)
          }(e, n) : i(e, n);
          if (!t.in &amp;&amp; o.in) return o.v ? function(e, n) {
               return d(e, n) ? {
                    v: !0,
                    h: !1,
                    in: !0,
                    col: o.col,
                    id: o.id
               } : l(e, n)
          }(e, n) : l(e, n);
          if (t.in &amp;&amp; o.in) return t.h || o.v ? t.h &amp;&amp; !o.v ? function(e, n) {
               return d(e, n) ? {
                    v: !1,
                    h: !0,
                    in: !0,
                    col: t.col,
                    id: t.id
               } : s(e, n) ? r() : {
                    v: !0,
                    h: !0,
                    in: !1,
                    col: null,
                    id: null
               }
          }(e, n) : !t.h &amp;&amp; o.v ? function(e, n) {
               return d(e, n) ? {
                    v: !0,
                    h: !1,
                    in: !0,
                    col: o.col,
                    id: o.id
               } : s(e, n) ? r() : {
                    v: !0,
                    h: !0,
                    in: !1,
                    col: null,
                    id: null
               }
          }(e, n) : c.rng() &lt;= c.chance_vertical ? {
               v: !0,
               h: !1,
               in: !0,
               col: o.col,
               id: o.id
          } : {
               v: !1,
               h: !0,
               in: !0,
               col: t.col,
               id: t.id
          } : {
               v: !1,
               h: !1,
               in: !0,
               col: t.col,
               id: t.id
          };

          function i(e, n) {
               return a(e, n) ? r() : {
                    v: !0,
                    h: !1,
                    in: !1,
                    col: null,
                    id: null
               }
          }

          function l(e, n) {
               return a(e, n) ? r() : {
                    v: !1,
                    h: !0,
                    in: !1,
                    col: null,
                    id: null
               }
          }

          function r() {
               let e;
               if (&quot;random&quot; === c.color_mode) e = c.get_random(c.colors);
               else if (&quot;main&quot; === c.color_mode) e = c.rng() &gt; .75 ? c.get_random(c.colors) : c.main_color;
               else if (&quot;group&quot; === c.color_mode) {
                    let n = c.rng() &gt; .5 ? t.col : o.col;
                    c.main_color = c.rng() &gt; c.group_size ? c.get_random(c.colors) : n || c.main_color, e = c.main_color
               } else e = c.main_color;
               return {
                    v: !0,
                    h: !0,
                    in: !0,
                    col: e,
                    id: c.id_counter++
               }
          }

          function a(e, n) {
               return !!c.simple || !!u(e, n, -1 * (1 - c.roundness)) &amp;&amp; c.rng() &lt;= c.solidness
          }

          function s(e, n) {
               return !!c.simple || !!u(e, n, 0) &amp;&amp; c.rng() &lt;= c.chance_new
          }

          function d(e, n) {
               return !(!u(e, n, 1 - c.roundness) &amp;&amp; !c.simple) &amp;&amp; c.rng() &lt;= c.chance_extend
          }

          function u(e, n, t) {
               let o = 1 + c.rng() * t;
               return Math.pow(e - c.xdim / 2, 2) / Math.pow(c.radius_x * o, 2) + Math.pow(n - c.ydim / 2, 2) / Math.pow(c.radius_y * o, 2) &lt; 1
          }
     }
     get_random(e) {
          return e[Math.floor(this.rng() * e.length)]
     }
}

function deep_copy(e) {
     let n = [];
     for (var t in e) e.hasOwnProperty(t) &amp;&amp; (n[t] = e[t]);
     return n
}

function convert_linegrid_to_rectangles(e) {
     let n = get_nw_corners(e);
     return extend_corners_to_rectangles(n, e), n
}

function get_nw_corners(e) {
     let n = [];
     for (let t = 0; t &lt; e.length; t++)
          for (let o = 0; o &lt; e[t].length; o++) {
               let c = e[t][o];
               c.h &amp;&amp; c.v &amp;&amp; c.in &amp;&amp; n.push({
                    x1: o,
                    y1: t,
                    col: c.col,
                    id: c.id
               })
          }
     return n
}

function extend_corners_to_rectangles(e, n) {
     e.map(e =&gt; {
          let t = 1;
          for (; e.x1 + t &lt; n[e.y1].length &amp;&amp; !n[e.y1][e.x1 + t].v;) t++;
          let o = 1;
          for (; e.y1 + o &lt; n.length &amp;&amp; !n[e.y1 + o][e.x1].h;) o++;
          return e.w = t, e.h = o, e
     })
}
const init_accuracy = Math.PI / 25;

function roughLine(e, n, t = 35) {
     const o = t * scale;
     const c = [{
          a: e,
          cp1: null,
          cp2: null
     }];
     for (; 0 != dist(c[c.length - 1].a, n) &amp;&amp; c.length &lt; 200;) {
          const e = getNextPoint(c, o, n);
          c.push(e)
     }
     return c
}

function getNextPoint(e, n, t) {
     let o = e[e.length - 1].a,
          c = dist(o, t),
          i = e[0].a,
          l = c / dist(i, t),
          r = n * (.5 * rng() + 1);
     if (c &lt;= 1.5 * r) return {
          a: t,
          cp1: null,
          cp2: null
     };
     let a = l * init_accuracy,
          s = angle_of_direction(o, t),
          d = rng() * a - a / 2,
          u = point_at_distance_and_angle(o, r, s + d);
     return {
          a: u,
          cp1: point_at_distance_towards_direction(u, -r / 3, t),
          cp2: point_at_distance_towards_direction(u, Math.min(r, dist(u, t)) / 3, t)
     }
}
const dist = (e, n) =&gt; Math.sqrt(Math.pow(n[0] - e[0], 2) + Math.pow(n[1] - e[1], 2)),
     angle_of_direction = (e, n) =&gt; Math.atan2(n[1] - e[1], n[0] - e[0]),
     point_at_distance_and_angle = (e, n, t) =&gt; [e[0] + n * Math.cos(t), e[1] + n * Math.sin(t)],
     point_at_distance_towards_direction = (e, n, t) =&gt; point_at_distance_and_angle(e, n, angle_of_direction(e, t));

function rnd() {
     seed ^= seed &lt;&lt; 13, seed ^= seed &gt;&gt; 17;
     const e = ((seed ^= seed &lt;&lt; 5) &lt; 0 ? 1 + ~seed : seed) % 1e5 / 1e5;
     return 0 === e || 1 === e ? .5 : e
}

function range(e, n) {
     return void 0 === n &amp;&amp; (n = e, e = 0), rng() * (n - e) + e
}

function rangeFloor(e, n) {
     return Math.floor(range(e, n))
}

function pick(e) {
     if (0 !== e.length) return e[rangeFloor(0, e.length)]
}

function w_pick(e, n) {
     const t = n.reduce((e, n) =&gt; [...e, e[e.length - 1] + n], [0]),
          o = range(t[t.length - 1]);
     return e[t.findIndex(e =&gt; e &gt; o) - 1]
}

function generateSeedFromTokenData(e) {
     return parseInt(e.hash.slice(0, 16), 16)
}

function get_palette() {
     var e = [{
          c: [&quot;#f1594a&quot;, &quot;#f5b50e&quot;, &quot;#14a160&quot;, &quot;#2969de&quot;, &quot;#885fa4&quot;],
          b: &quot;#e2e6e8&quot;,
          w: 1
     }, {
          c: [&quot;#ed555d&quot;, &quot;#41b797&quot;, &quot;#eda126&quot;, &quot;#7b5770&quot;],
          b: &quot;#2d1922&quot;,
          w: 1
     }, {
          c: [&quot;#ec6c26&quot;, &quot;#613a53&quot;, &quot;#e8ac52&quot;, &quot;#639aa0&quot;],
          b: &quot;#d5cda1&quot;,
          w: 2
     }, {
          c: [&quot;#809498&quot;, &quot;#d3990e&quot;, &quot;#ecddc5&quot;],
          b: &quot;#863f52&quot;,
          w: 2
     }, {
          c: [&quot;#6b5c6e&quot;, &quot;#4a2839&quot;, &quot;#d9574a&quot;],
          b: &quot;#ffc34b&quot;,
          w: 2
     }, {
          c: [&quot;#c37c2b&quot;, &quot;#f6ecce&quot;, &quot;#386a7a&quot;],
          b: &quot;#e3cd98&quot;,
          w: 2
     }, {
          c: [&quot;#4bae8c&quot;, &quot;#d0c1a0&quot;],
          b: &quot;#d06440&quot;,
          w: 2
     }, {
          c: [&quot;#d24c23&quot;, &quot;#7ba6bc&quot;, &quot;#f0c667&quot;, &quot;#ede2b3&quot;, &quot;#672b35&quot;],
          b: &quot;#108266&quot;,
          w: 1
     }, {
          c: [&quot;#e3937b&quot;, &quot;#d93f1d&quot;, &quot;#e6cca7&quot;],
          b: &quot;#558947&quot;,
          w: 1
     }, {
          c: [&quot;#d03718&quot;, &quot;#33762f&quot;, &quot;#ead7c9&quot;, &quot;#ce7028&quot;, &quot;#689d8d&quot;],
          b: &quot;#deb330&quot;,
          w: 2
     }, {
          c: [&quot;#eb5627&quot;, &quot;#eebb20&quot;, &quot;#4e9eb8&quot;, &quot;#f7f5d0&quot;],
          b: &quot;#77c1c0&quot;,
          w: 3
     }, {
          c: [&quot;#ff6555&quot;, &quot;#ffb58f&quot;, &quot;#d8eecf&quot;, &quot;#8c4b47&quot;, &quot;#bf7f93&quot;],
          b: &quot;#ffda82&quot;,
          w: 1
     }, {
          c: [&quot;#475b62&quot;, &quot;#7a999c&quot;, &quot;#fbaf3c&quot;, &quot;#df4a33&quot;, &quot;#f0e0c6&quot;, &quot;#af592c&quot;],
          b: &quot;#f0e0c6&quot;,
          w: 3
     }, {
          c: [&quot;#e85b30&quot;, &quot;#ef9e28&quot;, &quot;#c6ac71&quot;, &quot;#e0c191&quot;, &quot;#3f6279&quot;, &quot;#ee854e&quot;],
          b: &quot;#ede4cb&quot;,
          w: 2
     }, {
          c: [&quot;#c03a53&quot;, &quot;#edd09e&quot;, &quot;#aab5af&quot;, &quot;#124639&quot;, &quot;#eba735&quot;, &quot;#8e9380&quot;, &quot;#6c4127&quot;],
          b: &quot;#e6e2d6&quot;,
          w: 2
     }, {
          c: [&quot;#f4b232&quot;, &quot;#f2dbbd&quot;, &quot;#01799c&quot;, &quot;#e93e48&quot;, &quot;#006748&quot;, &quot;#ed817d&quot;, &quot;#2a2969&quot;],
          b: &quot;#f2dbbd&quot;,
          w: 1
     }, {
          c: [&quot;#FF514E&quot;, &quot;#FDBC2E&quot;, &quot;#4561CC&quot;, &quot;#6CC283&quot;, &quot;#238DA5&quot;, &quot;#9BD7CB&quot;],
          b: &quot;#2A303E&quot;,
          w: 1
     }, {
          c: [&quot;#ea663f&quot;, &quot;#f9cc27&quot;, &quot;#84afd7&quot;, &quot;#7ca994&quot;, &quot;#f1bbc9&quot;],
          b: &quot;#f5f6f1&quot;,
          w: 2
     }, {
          c: [&quot;#ff7a5a&quot;, &quot;#765aa6&quot;, &quot;#fee7bc&quot;, &quot;#515e8c&quot;, &quot;#ffc64a&quot;, &quot;#b460a6&quot;, &quot;#4781c1&quot;],
          b: &quot;#abe9e8&quot;,
          w: 3
     }, {
          c: [&quot;#ae5d9d&quot;, &quot;#f1e8bc&quot;, &quot;#ef8fa3&quot;, &quot;#f7c047&quot;, &quot;#58c9ed&quot;, &quot;#f77150&quot;],
          b: &quot;#00ae83&quot;,
          w: 3
     }, {
          c: [&quot;#FFC54A&quot;, &quot;#fee7bc&quot;, &quot;#54C4C6&quot;, &quot;#4781C1&quot;, &quot;#F36E4B&quot;, &quot;#515F8C&quot;],
          b: &quot;#FE98A6&quot;,
          w: 3
     }, {
          c: [&quot;#F99854&quot;, &quot;#fee7bc&quot;, &quot;#54C4C6&quot;, &quot;#6CC4EA&quot;, &quot;#F496A6&quot;, &quot;#B461A5&quot;],
          b: &quot;#FFC649&quot;,
          w: 3
     }, {
          c: [&quot;#36AA85&quot;, &quot;#043554&quot;, &quot;#FA3E2C&quot;, &quot;#F99D7F&quot;, &quot;#147562&quot;, &quot;#026F36&quot;],
          b: &quot;#022626&quot;,
          w: 2
     }, {
          c: [&quot;#D14991&quot;, &quot;#F6D031&quot;, &quot;#F0645B&quot;, &quot;#D2E4CE&quot;],
          b: &quot;#2C134C&quot;,
          w: 2
     }, {
          c: [&quot;#E59040&quot;, &quot;#DD4C2F&quot;, &quot;#106381&quot;, &quot;#F8B8B9&quot;, &quot;#018A82&quot;, &quot;#B4AFAB&quot;, &quot;#8DB4B9&quot;, &quot;#53293D&quot;, &quot;#2BAABB&quot;],
          b: &quot;#DBB560&quot;,
          w: 3
     }];
     return w_pick(e, e.map(e =&gt; e.w))
}</pre></body></html>