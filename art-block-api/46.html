<html><body><h1>Name: 70s Pop Series One</h1><h3>Artist: Daniel Catt</h3><h3>Description: Leaning into a retro 70s groove, the perfect art for your space-pad. The input is simple, just two tiles, but how they're rotated and placed, that's the magic.</h3><h3>https://70sPop.love</h3><hr/><p>Script JSON: {&quot;type&quot;:&quot;js&quot;,&quot;version&quot;:&quot;1.0&quot;,&quot;aspectRatio&quot;:&quot;1&quot;}</p><p>Script Type: js</p><p>Version: 1.0</p><p>Script Ratio: 1</p><p>Instructions: </p><p>Hashes Generated per Token: true</p><p>Dynamic Asset? true</p><hr/><p>Artist Ethereum Address: 0x29b2f895343cadfb3f5101bef6484b1f01c83dc9</p><p>Additional Payee: 0x29b2f895343cadfb3f5101bef6484b1f01c83dc9</p><p>Additional Payee Percentage: 100</p><p>Price: 0.128</p><p>Currency: ETH</p><p>Currency Address: N/A</p><p>Invocations: 256</p><p>Maximum Invocations: 256</p><p>License: NIFTY License</p><p>Token Ids: 46000000,46000001,46000002,46000003,46000004,46000005,46000006,46000007,46000008,46000009,46000010,46000011,46000012,46000013,46000014,46000015,46000016,46000017,46000018,46000019,46000020,46000021,46000022,46000023,46000024,46000025,46000026,46000027,46000028,46000029,46000030,46000031,46000032,46000033,46000034,46000035,46000036,46000037,46000038,46000039,46000040,46000041,46000042,46000043,46000044,46000045,46000046,46000047,46000048,46000049,46000050,46000051,46000052,46000053,46000054,46000055,46000056,46000057,46000058,46000059,46000060,46000061,46000062,46000063,46000064,46000065,46000066,46000067,46000068,46000069,46000070,46000071,46000072,46000073,46000074,46000075,46000076,46000077,46000078,46000079,46000080,46000081,46000082,46000083,46000084,46000085,46000086,46000087,46000088,46000089,46000090,46000091,46000092,46000093,46000094,46000095,46000096,46000097,46000098,46000099</p><p>Active? true</p><p>Paused? false</p><hr/><p><strong>Script:</strong></p><pre>! function(e, t, r, a, o, i, l, n, s) {
     function d(e) {
          var t, r = e.length,
               o = this,
               i = 0,
               l = o.i = o.j = 0,
               n = o.S = [];
          for (r || (e = [r++]); a &gt; i;) n[i] = i++;
          for (i = 0; a &gt; i; i++) n[i] = n[l = u &amp; l + e[i % r] + (t = n[i])], n[l] = t;
          (o.g = function(e) {
               for (var t, r = 0, i = o.i, l = o.j, n = o.S; e--;) t = n[i = u &amp; i + 1], r = r * a + n[u &amp; (n[i] = n[l = u &amp; l + t]) + (n[l] = t)];
               return o.i = i, o.j = l, r
          })(a)
     }

     function c(e, t) {
          for (var r, a = e + &quot;&quot;, o = 0; o &lt; a.length;) t[u &amp; o] = u &amp; (r ^= 19 * t[u &amp; o]) + a.charCodeAt(o++);
          return h(t)
     }

     function f(r) {
          try {
               return p ? h(p.randomBytes(a)) : (e.crypto.getRandomValues(r = new Uint8Array(a)), h(r))
          } catch (a) {
               return [+new Date, e, (r = e.navigator) &amp;&amp; r.plugins, e.screen, h(t)]
          }
     }

     function h(e) {
          return String.fromCharCode.apply(0, e)
     }
     var p, b = r.pow(a, 6),
          w = r.pow(2, 52),
          m = 2 * w,
          u = a - 1,
          x = r[&quot;seed&quot; + s] = function(e, o, i) {
               var l = [],
                    n = c(function e(t, r) {
                         var a, o = [],
                              i = typeof t;
                         if (r &amp;&amp; &quot;object&quot; == i)
                              for (a in t) try {
                                   o.push(e(t[a], r - 1))
                              } catch (e) {}
                         return o.length ? o : &quot;string&quot; == i ? t : t + &quot;\0&quot;
                    }((o = 1 == o ? {
                         entropy: !0
                    } : o || {}).entropy ? [e, h(t)] : null == e ? f() : e, 3), l),
                    p = new d(l);
               return c(h(p.S), t), (o.pass || i || function(e, t, a) {
                    return a ? (r[s] = e, t) : e
               })(function() {
                    for (var e = p.g(6), t = b, r = 0; w &gt; e;) e = (e + r) * a, t *= a, r = p.g(1);
                    for (; e &gt;= m;) e /= 2, t /= 2, r &gt;&gt;&gt;= 1;
                    return (e + r) / t
               }, n, &quot;global&quot; in o ? o.global : this == r)
          };
     if (c(r[s](), t), l &amp;&amp; l.exports) {
          l.exports = x;
          try {
               p = require(&quot;crypto&quot;)
          } catch (e) {}
     } else n &amp;&amp; n.amd &amp;&amp; n(function() {
          return x
     })
}(this, [], Math, 256, 0, 0, &quot;object&quot; == typeof module &amp;&amp; module, &quot;function&quot; == typeof define &amp;&amp; define, &quot;random&quot;),
function(e) {
     var t = e.noise = {};

     function r(e, t, r) {
          this.x = e, this.y = t, this.z = r
     }
     r.prototype.dot3 = function(e, t, r) {
          return this.x * e + this.y * t + this.z * r
     };
     var a = [new r(1, 1, 0), new r(-1, 1, 0), new r(1, -1, 0), new r(-1, -1, 0), new r(1, 0, 1), new r(-1, 0, 1), new r(1, 0, -1), new r(-1, 0, -1), new r(0, 1, 1), new r(0, -1, 1), new r(0, 1, -1), new r(0, -1, -1)],
          o = [151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23, 190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33, 88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71, 134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244, 102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250, 124, 123, 5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182, 189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9, 129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228, 251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107, 49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254, 138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180],
          i = new Array(512),
          l = new Array(512);
     t.seed = function(e) {
          e &gt; 0 &amp;&amp; e &lt; 1 &amp;&amp; (e *= 65536), (e = Math.floor(e)) &lt; 256 &amp;&amp; (e |= e &lt;&lt; 8);
          for (var t = 0; t &lt; 256; t++) {
               var r;
               r = 1 &amp; t ? o[t] ^ 255 &amp; e : o[t] ^ e &gt;&gt; 8 &amp; 255, i[t] = i[t + 256] = r, l[t] = l[t + 256] = a[r % 12]
          }
     }, t.seed(0);
     Math.sqrt(3), Math.sqrt(3);

     function n(e) {
          return e * e * e * (e * (6 * e - 15) + 10)
     }

     function s(e, t, r) {
          return (1 - r) * e + r * t
     }
     t.perlin3 = function(e, t, r) {
          var a = Math.floor(e),
               o = Math.floor(t),
               d = Math.floor(r);
          e -= a, t -= o, r -= d;
          var c = l[(a &amp;= 255) + i[(o &amp;= 255) + i[d &amp;= 255]]].dot3(e, t, r),
               f = l[a + i[o + i[d + 1]]].dot3(e, t, r - 1),
               h = l[a + i[o + 1 + i[d]]].dot3(e, t - 1, r),
               p = l[a + i[o + 1 + i[d + 1]]].dot3(e, t - 1, r - 1),
               b = l[a + 1 + i[o + i[d]]].dot3(e - 1, t, r),
               w = l[a + 1 + i[o + i[d + 1]]].dot3(e - 1, t, r - 1),
               m = l[a + 1 + i[o + 1 + i[d]]].dot3(e - 1, t - 1, r),
               u = l[a + 1 + i[o + 1 + i[d + 1]]].dot3(e - 1, t - 1, r - 1),
               x = n(e),
               g = n(t),
               M = n(r);
          return s(s(s(c, b, x), s(f, w, x), M), s(s(h, m, x), s(p, u, x), M), g)
     }
}(this);
const shuffleArray = e =&gt; {
          for (var t = e.length - 1; t &gt; 0; t--) {
               var r = Math.floor(Math.random() * (t + 1)),
                    a = e[t];
               e[t] = e[r], e[r] = a
          }
          return e
     },
     r2h = e =&gt; {
          let t = e.r,
               r = e.g,
               a = e.b,
               o = Math.max(t, r, a),
               i = o - Math.min(t, r, a),
               l = 1 - Math.abs(o + o - i - 1),
               n = i &amp;&amp; (o == t ? (r - a) / i : o == r ? 2 + (a - t) / i : 4 + (t - r) / i);
          return [60 * (n &lt; 0 ? n + 6 : n), l ? i / l : 0, (o + o - i) / 2]
     },
     h2r = (e, t, r) =&gt; {
          let a = t * Math.min(r, 1 - r),
               o = (t, o = (t + e / 30) % 12) =&gt; r - a * Math.max(Math.min(o - 3, 9 - o, 1), -1);
          return [o(0), o(8), o(4)]
     },
     x2r = e =&gt; {
          var t = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(e);
          return t ? {
               r: parseInt(t[1], 16),
               g: parseInt(t[2], 16),
               b: parseInt(t[3], 16)
          } : null
     },
     c2x = e =&gt; {
          var t = Math.floor(e).toString(16);
          return 1 == t.length ? &quot;0&quot; + t : t
     },
     r2x = e =&gt; `${c2x(e[0])}${c2x(e[1])}${c2x(e[2])}`,
     def = 2400;
let canvas = null,
     ctx = null,
     [size, sizeMod, mkr, border, tileSize, step, stepOffset, midPoint, cornerDistance] = new Array(8).fill(null);
const resizeCanvas = () =&gt; {
          for (size = Math.min(window.innerWidth, window.innerHeight), canvas = document.getElementsByTagName(&quot;canvas&quot;)[0], ctx = canvas.getContext(&quot;2d&quot;), canvas.width = size * devicePixelRatio, canvas.height = size * devicePixelRatio, canvas.style.width = size + &quot;px&quot;, canvas.style.height = size + &quot;px&quot;, sizeMod = size / def, ctx.scale(devicePixelRatio, devicePixelRatio), mkr = 18 * sizeMod * .8, s = 260; s &gt; 0; s -= 20) size &lt;= s &amp;&amp; (mkr *= .95);
          stepOffset = (step = (tileSize = (size - 2 * (border = 0)) / tiles) / lines) / 2, midPoint = size / 2 - border - tileSize / 2, cornerDistance = 2 * Math.pow(midPoint, 2), midPoint = size / 2
     },
     palettes = [];
palettes.push([&quot;2d01f7&quot;, &quot;8901f2&quot;, &quot;bc01dd&quot;, &quot;db01b6&quot;, &quot;f20189&quot;]), palettes.push([&quot;eafdf8&quot;, &quot;e5e9ec&quot;, &quot;ddcad9&quot;, &quot;d1b1cb&quot;, &quot;815a6a&quot;]), palettes.push([&quot;d7d9b1&quot;, &quot;84acce&quot;, &quot;827191&quot;, &quot;7d1d3f&quot;, &quot;f06c01&quot;]), palettes.push([&quot;93b5c6&quot;, &quot;ddedaa&quot;, &quot;f0cf65&quot;, &quot;d7816a&quot;, &quot;bd4f6c&quot;]), palettes.push([&quot;114b5f&quot;, &quot;1a936f&quot;, &quot;88d498&quot;, &quot;c6dabf&quot;, &quot;f3e9d2&quot;]), palettes.push([&quot;22115e&quot;, &quot;1b4394&quot;, &quot;87c6d4&quot;, &quot;bfd9d1&quot;, &quot;dcf2d0&quot;]), palettes.push([&quot;5e114e&quot;, &quot;6b1b94&quot;, &quot;9587d4&quot;, &quot;bfc7d9&quot;, &quot;d0f2e6&quot;]), palettes.push([&quot;cb4625&quot;, &quot;941b43&quot;, &quot;d487c6&quot;, &quot;d1bfd9&quot;, &quot;d0dcf2&quot;]), palettes.push([&quot;4f5e11&quot;, &quot;946b1b&quot;, &quot;d49587&quot;, &quot;d9bfc7&quot;, &quot;e6d0f2&quot;]), palettes.push([&quot;115e20&quot;, &quot;43941b&quot;, &quot;c6d487&quot;, &quot;d9d1bf&quot;, &quot;f2d0dc&quot;]), palettes.push([&quot;bbdef0&quot;, &quot;01a6a6&quot;, &quot;efca08&quot;, &quot;f49f0a&quot;, &quot;f08701&quot;]), palettes.push([&quot;f0bbde&quot;, &quot;a601a6&quot;, &quot;07f0c9&quot;, &quot;0af59f&quot;, &quot;01f088&quot;]), palettes.push([&quot;def0bb&quot;, &quot;a6a601&quot;, &quot;c907f0&quot;, &quot;9f0af5&quot;, &quot;8801f0&quot;]), palettes.push([&quot;bccdf0&quot;, &quot;016da7&quot;, &quot;f0c907&quot;, &quot;f59f0a&quot;, &quot;f08801&quot;]), palettes.push([&quot;1be7ff&quot;, &quot;6eeb83&quot;, &quot;e4ff1a&quot;, &quot;ffb801&quot;, &quot;ff5714&quot;]), palettes.push([&quot;3a405a&quot;, &quot;aec5eb&quot;, &quot;f9dec9&quot;, &quot;e9afa3&quot;, &quot;7c5846&quot;]);
let counter = 1;
const startTime = (new Date).getTime();
Math.seedrandom(tokenData.hash);
let lineTile1 = Math.random(),
     lineTile2 = Math.random(),
     borderChance = Math.random(),
     tiles = Math.floor((lineTile1 + lineTile2 / 2) / 1.5 * 14 + 5),
     lines = Math.floor(9 - (lineTile1 + lineTile2) / 2 * 8) + 1,
     phase = !1,
     double = Math.random() &lt; .0234375,
     linesBoost = 0;
Math.random() &lt; .1 &amp;&amp; linesBoost--, Math.random() &lt; .1 &amp;&amp; (linesBoost -= 2), Math.random() &lt; .1 &amp;&amp; linesBoost++, Math.random() &lt; .1 &amp;&amp; (linesBoost += 2), lines += linesBoost, tiles &gt;= 16 &amp;&amp; lines--, lines &lt; 1 &amp;&amp; (lines = 1), tiles &gt; 17 &amp;&amp; lines &gt; 5 &amp;&amp; (lines = 6);
let chance = .5,
     invertChance = .4,
     inverted = !1,
     pickSelector = Math.random(),
     format = &quot;Normal&quot;;
pickSelector &lt; .75 &amp;&amp; (pickSelector &lt; .6 ? (invertChance = .2, format = pickSelector &lt; .2 ? &quot;Middle&quot; : &quot;Noise&quot;) : format = Math.random() &lt; .5 ? &quot;Sideways&quot; : &quot;Top-bottom&quot;), Math.random() &lt;= invertChance &amp;&amp; (inverted = !0);
const paletteIndex = Math.floor(Math.random() * palettes.length),
     thisPalette = shuffleArray(palettes[paletteIndex]);
let startCol = thisPalette.pop(),
     endCol = thisPalette.pop();
const fixedStartCol = JSON.parse(JSON.stringify(startCol)),
     fixedEndCol = JSON.parse(JSON.stringify(endCol));
let composite = &quot;darken&quot;;
Math.random() &lt; .075 &amp;&amp; (composite = &quot;exclusion&quot;);
let fill = &quot;Normal&quot;,
     target = .2;
if (0 === paletteIndex &amp;&amp; (target = .8), Math.random() &lt; target &amp;&amp; (fill = &quot;Left-right&quot;, Math.random() &lt; .5 &amp;&amp; (fill = &quot;Top-down&quot;), Math.random() &lt; .2)) {
     const e = Math.random();
     fill = &quot;Radial&quot;, e &lt; .4 &amp;&amp; (fill = &quot;Radial-tl&quot;), e &lt; .3 &amp;&amp; (fill = &quot;Radial-tr&quot;), e &lt; .2 &amp;&amp; (fill = &quot;Radial-bl&quot;), e &lt; .1 &amp;&amp; (fill = &quot;Radial-br&quot;)
}
&quot;Normal&quot; !== fill &amp;&amp; Math.random() &lt;= .1 &amp;&amp; (phase = !0), &quot;exclusion&quot; === composite &amp;&amp; Math.random() &lt;= .25 &amp;&amp; (phase = !0);
let special = &quot;None&quot;,
     rotation = 0;
const specialChance = Math.random();
Math.random() &lt;= .05 &amp;&amp; (rotation = 90 * Math.floor(4 * Math.random()), special = &quot;scales&quot;, specialChance &lt; .76 &amp;&amp; (special = &quot;feather&quot;), specialChance &lt; .55 &amp;&amp; (special = &quot;flow&quot;), specialChance &lt; .38 &amp;&amp; (special = &quot;weave&quot;), specialChance &lt; .24 &amp;&amp; (special = &quot;tiles&quot;), specialChance &lt; .13 &amp;&amp; (special = &quot;zig&quot;), specialChance &lt; .05 &amp;&amp; (special = &quot;zag&quot;));
let decoration = &quot;None&quot;;
Math.random() &lt;= .07 &amp;&amp; (decoration = &quot;cornerRose&quot;, Math.random() &lt; .1 &amp;&amp; !(tiles % 2) &amp;&amp; tiles &gt; 6 &amp;&amp; (decoration = &quot;CornerRoseMiddle&quot;)), tiles % 2 || Math.random() &lt;= .08 &amp;&amp; (decoration = &quot;rose&quot;, Math.random() &lt; .25 &amp;&amp; (decoration = &quot;bigRose&quot;));
const originalDecoration = decoration,
     drawCorner = (e, t, r, a, o, i, l, n) =&gt; {
          i &amp;&amp; (ctx.beginPath(), ctx.moveTo(e, t), ctx.lineTo(r, a), ctx.arc(e, t, o, l * Math.PI, n * Math.PI), ctx.lineTo(e, t), ctx.fill()), ctx.beginPath(), ctx.arc(e, t, o, l * Math.PI, n * Math.PI), ctx.lineCap = &quot;round&quot;, ctx.stroke()
     },
     drawTL = (e, t, r) =&gt; drawCorner(e.left, e.top, e.right, e.top, t, r, 0, .5),
     drawTR = (e, t, r) =&gt; drawCorner(e.right, e.top, e.right, e.bottom, t, r, .5, 1),
     drawBR = (e, t, r) =&gt; drawCorner(e.right, e.bottom, e.left, e.bottom, t, r, 1, 1.5),
     drawBL = (e, t, r) =&gt; drawCorner(e.left, e.bottom, e.left, e.top, t, r, 1.5, 0),
     drawTile = (e, t, r) =&gt; {
          ctx.fillRect(e.left, e.top, tileSize, tileSize);
          let a = !0;
          for (l = lines - 1; l &gt;= 0; l--) {
               t(e, l * step + stepOffset, a), a = !1
          }
          for (a = !0, l = lines - 1; l &gt;= 0; l--) {
               r(e, l * step + stepOffset, a), a = !1
          }
     },
     dc = (e, t) =&gt; {
          drawTile(getPos(--e, --t), drawTL, drawBR), drawTile(getPos(e + 1, t), drawTR, drawBL), drawTile(getPos(e + 1, t + 1), drawBR, drawTL), drawTile(getPos(e, t + 1), drawBL, drawTR)
     },
     drawVert = e =&gt; {
          for (l = 0; l &lt; lines; l++) ctx.beginPath(), ctx.moveTo(e.left + l * step + stepOffset, e.top - 2), ctx.lineTo(e.left + l * step + stepOffset, e.bottom + 2), ctx.lineCap = &quot;butt&quot;, ctx.stroke()
     },
     drawHorz = e =&gt; {
          for (l = 0; l &lt; lines; l++) ctx.beginPath(), ctx.moveTo(e.left - 2, e.top + l * step + stepOffset), ctx.lineTo(e.right + 2, e.top + l * step + stepOffset), ctx.lineCap = &quot;butt&quot;, ctx.stroke()
     },
     getPos = (e, t) =&gt; ({
          left: border + tileSize * e,
          right: border + tileSize * (e + 1),
          top: border + tileSize * t,
          bottom: border + tileSize * (t + 1)
     }),
     makeTileHolders = () =&gt; {
          const e = [];
          for (let t = 0; t &lt; tiles; t++)
               for (let r = 0; r &lt; tiles; r++) {
                    const a = getPos(r, t);
                    if (&quot;Middle&quot; === format) {
                         const e = Math.pow(Math.abs(a.left + tileSize / 2 - midPoint), 2) + Math.pow(Math.abs(a.top + tileSize / 2 - midPoint), 2);
                         chance = e / cornerDistance
                    }
                    if (&quot;Sideways&quot; === format &amp;&amp; (chance = r / tiles * 1), &quot;Top-bottom&quot; === format &amp;&amp; (chance = t / tiles * 1), &quot;Noise&quot; === format) {
                         const e = Math.random();
                         chance = .7 - (noise.perlin3(r / 20 + e / 721, t / 20 + e / 883, e / 1e3) + 1) / 2
                    }
                    inverted &amp;&amp; (chance = 1 - chance), chance &lt; .1 &amp;&amp; (chance = .1), chance &gt; .9 &amp;&amp; (chance = .9);
                    let o = !1;
                    if (&quot;None&quot; !== special &amp;&amp; (&quot;feather&quot; === special &amp;&amp; r + t &lt; tiles - 1 &amp;&amp; (e.push([drawBR, drawTL]), o = !0), &quot;flow&quot; === special &amp;&amp; r + t &lt; tiles - 1 &amp;&amp; (e.push([drawTR, drawBL]), o = !0), &quot;tiles&quot; === special &amp;&amp; t &lt; tiles / 2 &amp;&amp; ((r + t) % 2 ? e.push([drawBR, drawTL]) : e.push([drawBL, drawTR]), o = !0), &quot;scales&quot; === special &amp;&amp; t &lt; tiles / 2 &amp;&amp; ((r + t) % 2 ? e.push([drawTL, drawBR]) : e.push([drawTR, drawBL]), o = !0), &quot;zig&quot; === special &amp;&amp; t &lt; tiles / 2 &amp;&amp; (t % 2 ? e.push([drawBR, drawTL]) : e.push([drawBL, drawTR]), o = !0), &quot;zag&quot; === special &amp;&amp; t &lt; tiles / 2 &amp;&amp; (r % 2 ? e.push([drawBR, drawTL]) : e.push([drawTL, drawBR]), o = !0), &quot;weave&quot; === special &amp;&amp; t &lt; tiles / 2 &amp;&amp; ((r + t) % 2 ? e.push([&quot;horz&quot;]) : e.push([&quot;vert&quot;]), o = !0)), !o)
                         if (Math.random() &gt;= chance) {
                              let t = drawTL,
                                   r = drawBR;
                              Math.random() &lt; .5 ? Math.random() &lt; .5 &amp;&amp; (t = drawBR, r = drawTL) : (t = drawTR, r = drawBL, Math.random() &lt; .5 &amp;&amp; (t = drawBL, r = drawTR)), e.push([t, r])
                         } else Math.random() &lt; .5 ? e.push([&quot;horz&quot;]) : e.push([&quot;vert&quot;])
               }
          return e
     },
     drawImage = () =&gt; {
          let e = 0;
          for (let t = 0; t &lt; tiles; t++)
               for (let r = 0; r &lt; tiles; r++) {
                    const a = tileHolders[e];
                    e++;
                    const o = getPos(r, t);
                    if (2 === a.length) {
                         let e = !0;
                         for (l = lines - 1; l &gt;= 0; l--) {
                              const t = l * step + stepOffset;
                              a[0](o, t, e), e = !1
                         }
                         for (e = !0, l = lines - 1; l &gt;= 0; l--) {
                              const t = l * step + stepOffset;
                              a[1](o, t, e), e = !1
                         }
                    } else &quot;horz&quot; === a[0] ? (drawHorz(o), ctx.beginPath(), ctx.rect(o.left + stepOffset, o.top, tileSize - step, tileSize), ctx.fill(), drawVert(o)) : (drawVert(o), ctx.beginPath(), ctx.rect(o.left, o.top + stepOffset, tileSize, tileSize - step), ctx.fill(), drawHorz(o))
               }
     },
     makeGrd = () =&gt; {
          let e = `#${startCol}`;
          return &quot;Left-right&quot; === fill &amp;&amp; (e = ctx.createLinearGradient(border, border, size - border, border)), &quot;Top-down&quot; === fill &amp;&amp; (e = ctx.createLinearGradient(border, border, border, size - border)), &quot;Radial&quot; === fill &amp;&amp; (e = ctx.createRadialGradient(size / 2, size / 2, 0, size / 2, size / 2, size)), &quot;Radial-tl&quot; === fill &amp;&amp; (e = ctx.createRadialGradient(border, border, 0, border, border, 1.41 * size)), &quot;Radial-tr&quot; === fill &amp;&amp; (e = ctx.createRadialGradient(size - border, border, 0, size - border, border, 1.41 * size)), &quot;Radial-bl&quot; === fill &amp;&amp; (e = ctx.createRadialGradient(border, size - border, 0, border, size - border, 1.41 * size)), &quot;Radial-br&quot; === fill &amp;&amp; (e = ctx.createRadialGradient(size - border, size - border, 0, size - border, size - border, 1.41 * size)), &quot;Normal&quot; !== fill &amp;&amp; (e.addColorStop(0, `#${startCol}`), e.addColorStop(1, `#${endCol}`)), e
     };
resizeCanvas();
const tileHolders = makeTileHolders(),
     drawTheThing = () =&gt; {
          ctx.globalCompositeOperation = &quot;source-over&quot;, ctx.fillStyle = &quot;white&quot;, ctx.strokeStyle = &quot;black&quot;, ctx.lineWidth = mkr, ctx.beginPath(), ctx.rect(0, 0, size, size), ctx.fill(), ctx.stroke(), ctx.fillStyle = &quot;white&quot;, ctx.beginPath(), ctx.rect(border, border, size - 2 * border, size - 2 * border), ctx.fill();
          const e = ctx.getTransform();
          for (r = 0; r &lt; rotation; r += 90) ctx.translate(size, 0), ctx.rotate(90 * Math.PI / 180);
          if (drawImage(), double &amp;&amp; (ctx.globalCompositeOperation = &quot;darken&quot;, drawImage()), ctx.setTransform(e), &quot;None&quot; !== decoration) {
               const e = Math.floor(tiles / 2),
                    t = tiles,
                    r = () =&gt; {
                         dc(1, 1), dc(2, 0), dc(0, 2), dc(1, 0), dc(0, 1), dc(0, 0), dc(t - 1, 1), dc(t - 2, 0), dc(t, 2), dc(t - 1, 0), dc(t, 1), dc(t, 0), dc(t - 1, t - 1), dc(t - 2, t), dc(t, t - 2), dc(t, t - 1), dc(t - 1, t), dc(t, t), dc(1, t - 1), dc(0, t - 2), dc(2, t), dc(0, t - 1), dc(1, t), dc(0, t)
                    };
               &quot;CornerRoseMiddle&quot; === decoration &amp;&amp; (r(), decoration = &quot;rose&quot;), &quot;cornerRose&quot; === decoration &amp;&amp; r(), &quot;bigRose&quot; === decoration &amp;&amp; (dc(e - 1, e - 1), dc(e + 1, e - 1), dc(e + 1, e + 1), dc(e - 1, e + 1), dc(e - 2, e), dc(e, e - 2), dc(e + 2, e), dc(e, e + 2), decoration = &quot;rose&quot;), &quot;rose&quot; === decoration &amp;&amp; (dc(e - 1, e), dc(e, e - 1), dc(e + 1, e), dc(e, e + 1), dc(e, e))
          }
          if (ctx.globalCompositeOperation = composite, ctx.fillStyle = makeGrd(), ctx.beginPath(), ctx.rect(border, border, size - 2 * border, size - 2 * border), ctx.fill(), phase) {
               const e = ((new Date).getTime() - startTime) / 100,
                    t = r2h(x2r(fixedStartCol)),
                    r = r2h(x2r(fixedEndCol));
               startCol = r2x(h2r(t[0] + e, t[1], t[2])), endCol = r2x(h2r(r[0] + e, r[1], r[2])), window.requestAnimationFrame(drawTheThing)
          }
     };
window.requestAnimationFrame(drawTheThing), window.onresize = (() =&gt; {
     resizeCanvas(), phase || window.requestAnimationFrame(drawTheThing)
});</pre></body></html>