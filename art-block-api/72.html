<html><body><h1>Name: Frammenti</h1><h3>Artist: Stefano Contiero</h3><h3>Description: Memories define us. Made of countless fragments, they are an ever-changing snapshot of our past. Frammenti is a digital explosion of life, inspired by our most personal treasures.</h3><h3>https://stefanocontiero.com/?h</h3><hr/><p>Script JSON: {&quot;type&quot;:&quot;p5js&quot;,&quot;version&quot;:&quot;1.0.0&quot;,&quot;aspectRatio&quot;:&quot;1&quot;,&quot;interactive&quot;:&quot;true&quot;,&quot;curation_status&quot;:&quot;curated&quot;}</p><p>Script Type: p5js</p><p>Version: 1.0.0</p><p>Script Ratio: 1</p><p>Instructions: </p><p>Hashes Generated per Token: true</p><p>Dynamic Asset? true</p><hr/><p>Artist Ethereum Address: 0x161b79d4e135693361cb42b6a3e8067c8c34e744</p><p>Additional Payee: 0x0000000000000000000000000000000000000000</p><p>Additional Payee Percentage: 0</p><p>Price: 0.12</p><p>Currency: ETH</p><p>Currency Address: N/A</p><p>Invocations: 555</p><p>Maximum Invocations: 555</p><p>License: CC BY-NC 4.0</p><p>Token Ids: 72000000,72000001,72000002,72000003,72000004,72000005,72000006,72000007,72000008,72000009,72000010,72000011,72000012,72000013,72000014,72000015,72000016,72000017,72000018,72000019,72000020,72000021,72000022,72000023,72000024,72000025,72000026,72000027,72000028,72000029,72000030,72000031,72000032,72000033,72000034,72000035,72000036,72000037,72000038,72000039,72000040,72000041,72000042,72000043,72000044,72000045,72000046,72000047,72000048,72000049,72000050,72000051,72000052,72000053,72000054,72000055,72000056,72000057,72000058,72000059,72000060,72000061,72000062,72000063,72000064,72000065,72000066,72000067,72000068,72000069,72000070,72000071,72000072,72000073,72000074,72000075,72000076,72000077,72000078,72000079,72000080,72000081,72000082,72000083,72000084,72000085,72000086,72000087,72000088,72000089,72000090,72000091,72000092,72000093,72000094,72000095,72000096,72000097,72000098,72000099</p><p>Active? true</p><p>Paused? false</p><hr/><p><strong>Script:</strong></p><pre>function Z(c) {
     let a = c.substring(1).match(/.{1,2}/g).map((v =&gt; X(v, 16) / 255)).map((v =&gt; v &lt;= .03928 ? v / 12.92 : Math.pow((v + .055) / 1.055, 2.4)));
     return .2126 * a[0] + .7152 * a[1] + .0722 * a[2]
}

function setup() {
     let o, m, t, v, g, l, i = tokenData.hash,
          G = x =&gt; X(`0x${i.slice(2+x-16,16)}`, 16),
          n = 0,
          y = 0;
     z = (x, s, e) =&gt; I(x, 0, 256, s, e), q = (x, s, e) =&gt; W(z(x, s, e));
     for (let j = 0; j &lt; 32; j++) a.push(i.slice(2 + 2 * j, 4 + 2 * j));
     a = a.map((x =&gt; X(x, 16))), f = {
          a: a[4] &lt; 64,
          b: q(a[8], 0, P.length),
          d: z(a[11], .03, .16),
          e: z(a[22], .03, .16),
          g: q(a[12], 3, 8),
          h: a[15] &lt; 85 ? -1 : z(a[16], 3, 3.3),
          i: q(a[14], 5, 10),
          j: q(a[17], 0, 10),
          k: q(a[25], 1, 6),
          l: q(a[26], 1, 6),
          m: z(a[2], .2, .9),
          p: z(a[3], 25, 90),
          r: a[2] &lt; 128,
          s: z(a[31], 0, .3),
          t: a[18] &lt; 32
     }, f.t &amp;&amp; (f.e = f.d, f.l = f.k), -1 === f.h &amp;&amp; (f.i -= 2, f.j *= 3), a[13] &gt; 224 &amp;&amp; (f.g = 360), f.k &gt; 3 &amp;&amp; f.i--, f.l &gt; 3 &amp;&amp; f.i--, f.i &lt; 3 &amp;&amp; (f.j = 0), p = P[f.b], f.c = q(a[21], 0, p.length), f.n = q(a[23], 0, p.length), b = p[f.c], o = Z(b);
     do {
          f.n = (f.n + y++) % p.length, k = p[f.n], m = Z(k), n = (O(o, m) + .05) / (F(o, m) + .05)
     } while (n &lt; 3);
     f.o = 1e3 / (f.i + (-1 === f.h ? 4 : 0)) * (O(f.d, f.e) / (O(f.k, f.l) + 1)), f.a ? f.r &amp;&amp; (f.o *= 2.5, p = p.filter((c =&gt; c != b))) : f.o = a[30] &lt; 128 &amp;&amp; -1 === f.h ? f.j = 0 : F(f.o / (f.i / 5), 4), d = windowWidth, e = windowHeight, createCanvas(d, e), t = F(d, e), u = t / r, w = t - t * f.d * 2, h = t - t * f.e * 2, f.d *= d, f.e *= e, d -= f.d, e -= f.e, randomSeed(G(16)), noiseSeed(G(32)), noiseDetail(8, .4), frameRate(120), colorMode(HSB, 360, 100, 100, 100), strokeJoin(BEVEL), strokeWeight(f.o * u || 2 * u), A = randomGaussian, B = random, D = createVector, E = constrain, H = noise, M = background, N = hue, U = saturation, Q = brightness, T = color, J = p5.Vector.lerp, K = radians, b = C.O(b, 100, f.a ? 100 : f.p), k = C.O(k, 25), c = f.m, v = h / f.k, g = w / f.l, l = .8 * F(v, g);
     for (let i = 0; i &lt; f.k; i++)
          for (let k = 0; k &lt; f.l; k++) s.push(new S(W(E(f.g + 2 * A(), 3, 100)), l, (k + .5) * g, (i + .5) * v));
     for (let i = 0; i &lt; f.i; i++) {
          let d = [];
          for (let j = 0; j &lt; s.length; j++) {
               d.push(s[j]);
               let k = s[j].S(i);
               null !== k &amp;&amp; (k.O(), d.push(k))
          }
          s = d
     }
     for (let i = 0; i &lt;= f.j; i++)
          for (let j = 0; j &lt; s.length; j++) s[j].X()
}

function draw() {
     M(360), M(b);
     for (let j = 0; j &lt; s.length; j++) s[j].D(), s[j].U();
     frameCount % 120 == 0 &amp;&amp; Y()
}

function Y() {
     c = 0 !== i ? c - .05 : 1.01 * c, 1 !== i &amp;&amp; c &gt; 1 + A() / 10 ? (i = 1, c = 2) : 1 === i &amp;&amp; c &lt; 1 ? i = -1 : -1 === i &amp;&amp; c &lt; .8 &amp;&amp; (i = 0, c = f.m)
}

function mousePressed() {
     c = 0 !== i ? c - .1 : 1.5 * c, Y()
}
let b, c, d, e, f, h, k, m, p, u, w, A, B, D, E, H, M, N, U, Q, T, J, K, P = &quot;1b3b4bd40000b68762eef2f6e6e0dae0b299eda67de2725bz0505041d34611f487d237ba133b2cce6e6e6fdd692fb3640z1e90ffff514eff7700f7e3d569b6682b9091486abd282e39z1d2f53ec5c23fdc449f5f1ebf8b8a03cb8a472c1c65898c1zffbb33f1faeea8dadc457b9d1d3557031927424b54042a2bz26437fffcc00d2292effffff0000001884bffefddfd9381e&quot;.split `z`.map((c =&gt; c.match(/.{6}/g).map((s =&gt; &quot;#&quot; + s)))),
     I = (x, a, b, c, d) =&gt; (x - a) * (d - c) / (b - a) + c,
     X = parseInt,
     {
          min: F,
          max: O,
          floor: W
     } = Math,
     a = [],
     i = 0,
     r = 2400,
     s = [],
     C = {
          R: (i = B(1)) =&gt; p[W(100 * p.length * H(i, 100)) % p.length],
          O(c, x, a) {
               let h = N(c),
                    s = U(c),
                    b = Q(c);
               return h = (h + A() * (x / 25)) % 360, s = E(s + A() * (x / 25), 0, 100), b = E(b + A() * (x / 25), 0, 100), T(h, s, b, a)
          }
     };
class V {
     constructor(x, y, l) {
          this.l = l || D(x, y), this.p = null, this.n = null, this.i = this.l.copy()
     }
}
class S {
     constructor(e, s, x, y, l) {
          if (this.l = l ? l.copy() : D(x, y), this.n = D(0, 0), this.o = D(0, 0), this.v = [], this.c = !f.a || f.r ? C.O(C.R(), 100) : k, this.e = abs(2 * A()), this.i = B(1e6), this.a = B(-1e3, 1e3), this.m = B(-.02, .02), this.k = this.e, l) return;
          let r = s / 2,
               a = K(360 / e),
               o = K(B(360));
          for (let i = 0; i &lt; e; i++) {
               let x = cos(a * i + o) * r,
                    y = sin(a * i + o) * r,
                    v = new V(x, y);
               this.v.push(v)
          }
          S.U(this.v)
     }
     static U(t) {
          let z, p;
          for (let i = 0; i &lt; t.length; i++) {
               let v = t[i];
               0 === i ? z = v : (v.p = p, p.n = v), p = v
          }
          z.p = p, p.n = z
     }
     S(i) {
          let {
               v,
               l
          } = this, t = new S(0, 0, 0, 0, l), m = W(B(0, v.length)), n = W(B(3, v.length - f.h)), s = v[m], e = s;
          for (let i = 0; i &lt; n; i++) e = e.n;
          !(-1 === f.h || i &lt; 2) || e !== s &amp;&amp; e !== s.p &amp;&amp; e !== s.n || (e = s.n.n);
          let q = E(A() * f.s + .5, 0, 1),
               k = E(A() * f.s + .5, 0, 1),
               w = new V(0, 0, J(s.l, s.p.l, q)),
               h = new V(0, 0, J(e.l, e.p.l, k)),
               x = new V(0, 0, w.l.copy()),
               y = new V(0, 0, h.l.copy()),
               z = [w],
               c = s;
          if (w.l.dist(h.l) &lt; u) return null;
          for (; c !== e;) z.push(c), c = c.n;
          for (z.push(h), S.U(z), w = x, h = y, t.v.push(h), c = e; c !== s;) t.v.push(c), c = c.n;
          return t.v.push(w), S.U(t.v), this.v = z, t
     }
     O() {
          let z, y, w, u, a, {
                    o,
                    v
               } = this,
               s = 0;
          for (let i = 0; i &lt; v.length - 1; i++) z = v[i].l.x, y = v[i].l.y, w = v[i + 1].l.x, u = v[i + 1].l.y, a = z * u - w * y, s += a, o.x += (z + w) * a, o.y += (y + u) * a;
          z = v[v.length - 1].l.x, y = v[v.length - 1].l.y, w = v[0].l.x, u = v[0].l.y, a = z * u - w * y, s += a, o.x += (z + w) * a, o.y += (y + u) * a, s *= .5, o.x /= 6 * s, o.y /= 6 * s
     }
     X() {
          let {
               m,
               i,
               e,
               n
          } = this;
          n.x += I(H(n.x / (500 * u), n.y / (500 * u), i), 0, .8, -u, u) * e, n.y += I(H(n.y / (500 * u), n.x / (500 * u), 4 * i), 0, .8, -u, u) * e, this.e += m
     }
     U() {
          let {
               v,
               n,
               a,
               e,
               o,
               k
          } = this, b = a * e / 5e5;
          if (1 !== i) {
               if (-1 === i) {
                    n.lerp(D(0, 0), .05), this.e = lerp(k, e, .05);
                    for (let i = 0; i &lt; v.length; i++) v[i].l.lerp(v[i].i, .05)
               }
               n.x += B(-u, u) * c / 2, n.y += B(-u, u) * c / 2
          } else {
               this.X();
               for (let i = 0; i &lt; v.length; i++) {
                    let l = v[i].l;
                    l.sub(o), l.x = l.x * cos(b) - l.y * sin(b), l.y = l.y * cos(b) + l.x * sin(b), l.add(o)
               }
          }
     }
     D() {
          let {
               v,
               l,
               n,
               c
          } = this, x = I(l.x, 0, w, f.d, d), y = I(l.y, 0, h, f.e, e);
          f.a ? noFill() : fill(c), stroke(!f.o || f.a ? c : T(0, 75)), beginShape();
          for (let i = 0; i &lt; v.length; i++) vertex(n.x + x + v[i].l.x, n.y + y + v[i].l.y);
          vertex(n.x + x + v[0].l.x, n.y + y + v[0].l.y), endShape()
     }
}</pre></body></html>