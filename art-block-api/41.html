<html><body><h1>Name: Elementals</h1><h3>Artist: Michael Connolly</h3><h3>Description: Elementals is inspired by physical printmaking techniques and early Bauhaus principles. It starts with a few basic coloured shapes and arranges them in varying frequencies, sizes, and positions based on a unique transaction hash. Multiple overlaid variable grids allow for myriad layouts and opportunities for colour interaction. The goal is to create pieces that feel both intentional in composition and part of the same family.</h3><h3>https://linktr.ee/_mconnolly_</h3><hr/><p>Script JSON: {&quot;type&quot;:&quot;p5js&quot;,&quot;aspectRatio&quot;:&quot;1&quot;,&quot;version&quot;:&quot;1.0.0&quot;,&quot;curation_status&quot;:&quot;curated&quot;}</p><p>Script Type: p5js</p><p>Version: 1.0.0</p><p>Script Ratio: 1</p><p>Instructions: </p><p>Hashes Generated per Token: true</p><p>Dynamic Asset? true</p><hr/><p>Artist Ethereum Address: 0xf92bb2215684c353b4009395061ee7652883c365</p><p>Additional Payee: 0x0000000000000000000000000000000000000000</p><p>Additional Payee Percentage: 0</p><p>Price: 0.125</p><p>Currency: ETH</p><p>Currency Address: N/A</p><p>Invocations: 600</p><p>Maximum Invocations: 600</p><p>License: CC BY-NC 4.0</p><p>Token Ids: 41000000,41000001,41000002,41000003,41000004,41000005,41000006,41000007,41000008,41000009,41000010,41000011,41000012,41000013,41000014,41000015,41000016,41000017,41000018,41000019,41000020,41000021,41000022,41000023,41000024,41000025,41000026,41000027,41000028,41000029,41000030,41000031,41000032,41000033,41000034,41000035,41000036,41000037,41000038,41000039,41000040,41000041,41000042,41000043,41000044,41000045,41000046,41000047,41000048,41000049,41000050,41000051,41000052,41000053,41000054,41000055,41000056,41000057,41000058,41000059,41000060,41000061,41000062,41000063,41000064,41000065,41000066,41000067,41000068,41000069,41000070,41000071,41000072,41000073,41000074,41000075,41000076,41000077,41000078,41000079,41000080,41000081,41000082,41000083,41000084,41000085,41000086,41000087,41000088,41000089,41000090,41000091,41000092,41000093,41000094,41000095,41000096,41000097,41000098,41000099</p><p>Active? true</p><p>Paused? false</p><hr/><p><strong>Script:</strong></p><pre>let hashPairs = [];
for (let t = 0; t &lt; 32; t++) hashPairs.push(tokenData.hash.slice(2 + 2 * t, 4 + 2 * t));
const decPairs = hashPairs.map(t =&gt; parseInt(t, 16));
let unit, unit2, unit3, count, count2, count3, offset, offsetH, offsetB, offsetHB, styleMaster, countX, countX2, strokeThick, seed = parseInt(tokenData.hash.slice(0, 16), 16),
     gridLoops1 = [],
     gridLoops2 = [],
     gridLoops_stroke = [],
     rectY = !0,
     ellipseY = !1,
     tri1Y = !1,
     tri2Y = !1,
     gradY = !1,
     space1Y = !1,
     space2Y = !1,
     smlRect = !1,
     smlEllipse = !1,
     rectGradY = !1;
const Y_AXIS = 1,
     X_AXIS = 2;
let b1, b2, c1, c2, myColRnd1, myColRnd2, myColRnd3, palSwitch;
var palette;

function setup() {
     const t = windowWidth &lt; windowHeight ? windowWidth : windowHeight;
     createCanvas(t, t), blendMode(MULTIPLY), strokeCap(SQUARE), strokeThick = t / 300, offset = decPairs[1] &lt;= 85 ? t / 3 : decPairs[1] &gt; 85 &amp;&amp; decPairs[1] &lt;= 170 ? t / 4 : t / 2.5, countX = decPairs[2] &lt;= 85 ? 0 : decPairs[2] &gt; 85 &amp;&amp; decPairs[2] &lt; 170 ? 1 : 2, countX2 = decPairs[3] &lt;= 85 ? 0 : 1, offsetH = offset, offsetHB = offsetB = t / 3, unit = floor(map(decPairs[4], 0, 255, 2, 6)), unit2 = floor(map(decPairs[5], 0, 255, 3, 6)), unit3 = floor(map(decPairs[6], 0, 255, 2, 7)), count = (t - offset) / unit, count2 = (t - offset) / unit2, count3 = (t - offsetB) / unit3, palSwitch = map(decPairs[10], 0, 255, 0, 1), palette = palSwitch &lt;= .5 ? [color(244, 172, 20), color(241, 155, 194), color(177, 34, 35), color(69, 139, 151), color(190, 171, 138)] : [color(&quot;#3FB8AF&quot;), color(&quot;#7FC7AF&quot;), color(&quot;#DAD8A7&quot;), color(&quot;#FF9E9D&quot;), color(&quot;#FF3D7F&quot;), color(&quot;#69D2E7&quot;), color(&quot;#A7DBD8&quot;), color(&quot;#E0E4CC&quot;), color(&quot;#F38630&quot;), color(&quot;#FA6900&quot;)], c1 = color(palette[int(R.random_between(0, palette.length))]), c2 = color(palette[int(R.random_between(0, palette.length))]);
     for (let t = 0; t &lt; countX; t++) gridLoops1.push(new GridLooper(unit, unit, count, c1, c2));
     for (let t = 0; t &lt; 1; t++) gridLoops2.push(new GridLooper(unit2, unit2, count2, c1, c2));
     for (let t = 0; t &lt; countX2; t++) gridLoops_stroke.push(new GridLooper_stroke(unit3, unit3, count3, strokeThick));
     decPairs[7] &lt;= 85 ? background(200) : decPairs[7] &gt; 85 &amp;&amp; decPairs[7] &lt; 170 ? (background(palette[int(R.random_between(0, palette.length))]), fill(200, 50), noStroke(), rect(0, 0, innerWidth, innerHeight)) : background(palette[int(R.random_between(0, palette.length))]);
     for (let t = 0; t &lt; gridLoops1.length; t++) gridLoops1[t].display();
     for (let t = 0; t &lt; gridLoops2.length; t++) gridLoops2[t].display();
     for (let t = 0; t &lt; gridLoops_stroke.length; t++) gridLoops_stroke[t].display()
}
class Random {
     constructor(t) {
          this.seed = t
     }
     random_dec() {
          return this.seed ^= this.seed &lt;&lt; 13, this.seed ^= this.seed &gt;&gt; 17, this.seed ^= this.seed &lt;&lt; 5, (this.seed &lt; 0 ? 1 + ~this.seed : this.seed) % 1e3 / 1e3
     }
     random_between(t, e) {
          return t + (e - t) * this.random_dec()
     }
     random_int(t, e) {
          return Math.floor(this.random_between(t, e + 1))
     }
     random_choice(t) {
          return t[Math.floor(this.random_between(0, .99 * t.length))]
     }
}
let R = new Random(seed);

function setGradient(t, e, s, i, c, r, o) {
     if (noFill(), o === Y_AXIS)
          for (let o = e; o &lt;= e + i; o++) {
               let l = map(o, e, e + i, 0, 1),
                    f = lerpColor(c, r, l);
               stroke(f), line(t, o, t + s, o)
          } else if (o === X_AXIS)
               for (let o = t; o &lt;= t + s; o++) {
                    let l = map(o, t, t + s, 0, 1),
                         f = lerpColor(c, r, l);
                    stroke(f), line(o, e, o, e + i)
               }
}
class GridLooper {
     constructor(t, e, s, i, c) {
          this.k = t, this.l = e, this.c = s, this.rnd1 = i, this.rnd2 = c
     }
     display() {
          for (let t = 0; t &lt; this.k; t++)
               for (let e = 0; e &lt; this.l; e++) {
                    if (0 == (styleMaster = floor(R.random_between(0, 9))) ? (rectY = !0, ellipseY = !1, tri1Y = !1, tri2Y = !1, gradY = !1, space1Y = !1, space2Y = !1, smlRect = !1, smlEllipse = !1, rectGradY = !1) : 1 == styleMaster ? (rectY = !1, ellipseY = !0, tri1Y = !1, tri2Y = !1, gradY = !1, space1Y = !1, space2Y = !1, smlRect = !1, smlEllipse = !1, rectGradY = !1) : 2 == styleMaster ? (rectY = !1, ellipseY = !1, tri1Y = !0, tri2Y = !1, gradY = !1, space1Y = !1, space2Y = !1, smlRect = !1, smlEllipse = !1, rectGradY = !1) : 3 == styleMaster ? (rectY = !1, ellipseY = !1, tri1Y = !1, tri2Y = !0, gradY = !1, space1Y = !1, space2Y = !1, smlRect = !1, smlEllipse = !1, rectGradY = !1) : 4 == styleMaster ? (rectY = !1, ellipseY = !1, tri1Y = !1, tri2Y = !1, gradY = !0, space1Y = !1, space2Y = !1, smlRect = !1, smlEllipse = !1, rectGradY = !1) : 5 == styleMaster ? (rectY = !1, ellipseY = !1, tri1Y = !1, tri2Y = !1, gradY = !1, space1Y = !0, space2Y = !1, smlRect = !1, smlEllipse = !1, rectGradY = !1) : 6 == styleMaster ? (rectY = !1, ellipseY = !1, tri1Y = !1, tri2Y = !1, gradY = !1, space1Y = !1, space2Y = !0, smlRect = !1, smlEllipse = !1, rectGradY = !1) : 7 == styleMaster ? (rectY = !1, ellipseY = !1, tri1Y = !1, tri2Y = !1, gradY = !1, space1Y = !1, space2Y = !1, smlRect = !0, smlEllipse = !1, rectGradY = !1) : 8 == styleMaster ? (rectY = !1, ellipseY = !1, tri1Y = !1, tri2Y = !1, gradY = !1, space1Y = !1, space2Y = !1, smlRect = !1, smlEllipse = !0, rectGradY = !1) : 9 == styleMaster &amp;&amp; (rectY = !1, ellipseY = !1, tri1Y = !1, tri2Y = !1, gradY = !1, space1Y = !1, space2Y = !1, smlRect = !1, smlEllipse = !1, rectGradY = !0), noStroke(), fill(palette[int(R.random_between(0, palette.length))]), rectY)
                         if (R.random_between(0, 1) &lt;= .9) rect(t * this.c + offset / 2, e * this.c + offsetH / 2, this.c, this.c);
                         else if (R.random_between(0, 1) &gt; .9 &amp;&amp; R.random_between(0, 1) &lt;= .99) setGradient(t * this.c + offset / 2, e * this.c + offsetH / 2, this.c, this.c, this.rnd1, this.rnd2, Y_AXIS);
                    else {
                         decPairs[9] &lt;= 127.5 ? fill(0) : (blendMode(ADD), fill(255));
                         for (let s = 0; s &lt; 20; s++) rect(t * this.c + offset / 2, e * this.c + offsetH / 2 + s * this.c / 20, this.c, this.c / 40);
                         blendMode(MULTIPLY)
                    }
                    ellipseY &amp;&amp; (R.random_between(0, 1) &lt; .9 ? ellipse(t * this.c + offset / 2 + this.c / 2, e * this.c + offsetH / 2 + this.c / 2, this.c, this.c) : (blendMode(ADD), fill(255), ellipse(t * this.c + offset / 2 + this.c / 2, e * this.c + offsetH / 2 + this.c / 2, this.c / 4, this.c / 4), blendMode(MULTIPLY))), tri1Y &amp;&amp; (decPairs[11] &lt;= 229.5 ? triangle(t * this.c + offset / 2, e * this.c + offsetH / 2 + this.c, t * this.c + offset / 2 + this.c, e * this.c + offsetH / 2, t * this.c + offset / 2 + this.c, e * this.c + offsetH / 2 + this.c) : triangle(t * this.c + offset / 2, e * this.c + offsetH / 2, t * this.c + offset / 2 + this.c, e * this.c + offsetH / 2, t * this.c + offset / 2, e * this.c + offsetH / 2 + this.c)), tri2Y &amp;&amp; (decPairs[11] &lt;= 229.5 ? triangle(t * this.c + offset / 2, e * this.c + offsetH / 2, t * this.c + offset / 2 + this.c, e * this.c + offsetH / 2, t * this.c + offset / 2 + this.c, e * this.c + offsetH / 2 + this.c) : triangle(t * this.c + offset / 2, e * this.c + offsetH / 2, t * this.c + offset / 2, e * this.c + offsetH / 2 + this.c, t * this.c + offset / 2 + this.c, e * this.c + offsetH / 2 + this.c)), gradY &amp;&amp; (R.random_between(0, 1) &lt; .5 ? setGradient(t * this.c + offset / 2, e * this.c + offsetH / 2, this.c / 2, this.c, this.rnd1, this.rnd2, Y_AXIS) : setGradient(t * this.c + offset / 2, e * this.c + offsetH / 2, this.c / 2, this.c / 2, this.rnd2, this.rnd1, Y_AXIS))
               }
     }
}
class GridLooper_stroke {
     constructor(t, e, s, i) {
          this.k = t, this.l = e, this.c = s, this.sw = i
     }
     display() {
          for (let t = 0; t &lt; this.k; t++)
               for (let e = 0; e &lt; this.l; e++) 0 == (styleMaster = floor(R.random_between(0, 6))) ? (rectY = !0, ellipseY = !1, tri1Y = !1, tri2Y = !1, space1Y = !1, space2Y = !1) : 1 == styleMaster ? (rectY = !1, ellipseY = !0, tri1Y = !1, tri2Y = !1, space1Y = !1, space2Y = !1) : 2 == styleMaster ? (rectY = !1, ellipseY = !1, tri1Y = !0, tri2Y = !1, space1Y = !1, space2Y = !1) : 3 == styleMaster ? (rectY = !1, ellipseY = !1, tri1Y = !1, tri2Y = !0, space1Y = !1, space2Y = !1) : 4 == styleMaster ? (rectY = !1, ellipseY = !1, tri1Y = !1, tri2Y = !1, space1Y = !0, space2Y = !1) : 5 == styleMaster &amp;&amp; (rectY = !1, ellipseY = !1, tri1Y = !1, tri2Y = !1, space1Y = !1, space2Y = !0), noFill(), strokeWeight(this.sw), decPairs[8] &lt;= 127.5 ? (blendMode(ADD), stroke(255)) : stroke(0), rectY &amp;&amp; rect(t * this.c + offsetB / 2, e * this.c + offsetHB / 2, this.c, this.c), ellipseY &amp;&amp; ellipse(t * this.c + offsetB / 2 + this.c / 2, e * this.c + offsetHB / 2 + this.c / 2, this.c, this.c), tri1Y &amp;&amp; (decPairs[11] &lt;= 229.5 ? triangle(t * this.c + offsetB / 2, e * this.c + offsetHB / 2 + this.c, t * this.c + offsetB / 2 + this.c, e * this.c + offsetHB / 2, t * this.c + offsetB / 2 + this.c, e * this.c + offsetHB / 2 + this.c) : triangle(t * this.c + offsetB / 2, e * this.c + offsetHB / 2, t * this.c + offsetB / 2 + this.c, e * this.c + offsetHB / 2, t * this.c + offsetB / 2, e * this.c + offsetHB / 2 + this.c)), tri2Y &amp;&amp; (decPairs[11] &lt;= 229.5 ? triangle(t * this.c + offsetB / 2, e * this.c + offsetHB / 2, t * this.c + offsetB / 2 + this.c, e * this.c + offsetHB / 2, t * this.c + offsetB / 2 + this.c, e * this.c + offsetHB / 2 + this.c) : triangle(t * this.c + offsetB / 2, e * this.c + offsetHB / 2, t * this.c + offsetB / 2, e * this.c + offsetHB / 2 + this.c, t * this.c + offsetB / 2 + this.c, e * this.c + offsetHB / 2 + this.c)), blendMode(MULTIPLY)
     }
}</pre></body></html>