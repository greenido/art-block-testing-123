<html>
  <head>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.2.0/p5.js"></script>
    <script>
      // Token Ids: 10000000,10000001,10000002,10000003,10000004,10000005,10000006,10000007,10000008,10000009,10000010,10000011,10000012,10000013,10000014,10000015,10000016,10000017,10000018,10000019,10000020,10000021,10000022,10000023,10000024,10000025,10000026,10000027,10000028,10000029,10000030,10000031,10000032,10000033,10000034,10000035,10000036,10000037,10000038,10000039,10000040,10000041,10000042,10000043,10000044,10000045,10000046,10000047,10000048,10000049,10000050,10000051,10000052,10000053,10000054,10000055,10000056,10000057,10000058,10000059,10000060,10000061,10000062,10000063,10000064,10000065,10000066,10000067,10000068,10000069,10000070,10000071,10000072,10000073,10000074,10000075,10000076,10000077,10000078,10000079,10000080,10000081,10000082,10000083,10000084,10000085,10000086,10000087,10000088,10000089,10000090,10000091,10000092,10000093,10000094,10000095,10000096,10000097,10000098,10000099
      let tokenData = {
        hash:
          "0x2ed5912b84b7777777777772735e5a45416a5a723172a643ca545bee87be96c2",
        //"0x2ed5912b84b45dad487dd392735e5a45416a5a723172a643ca545bee87be96c2", 0x9C238282Db349A20d501c5bfeE13ed29ae5a451C",
        tokenId: "500005"
      };
    </script>
    <style type="text/css">
      body {
        margin: 0;
        padding: 0;
      }

      canvas {
        padding: 0;
        margin: auto;
        display: block;
        position: absolute;
        top: 0;
        bottom: 0;
        left: 0;
        right: 0;
      }
    </style>
  </head>
  <body>
    <center>
      <h1>
        5 üçæ
      </h1>
      <a href="https://api.artblocks.io/project/5">project 5</a>
    </center>
    <script>
      let hashPairs = [];
for (let t = 0; t < 32; t++) hashPairs.push(tokenData.hash.slice(2 + 2 * t, 4 + 2 * t));
const decPairs = hashPairs.map(t => parseInt(t, 16));
let unit, unit2, unit3, count, count2, count3, offset, offsetH, offsetB, offsetHB, styleMaster, countX, countX2, strokeThick, seed = parseInt(tokenData.hash.slice(0, 16), 16),
     gridLoops1 = [],
     gridLoops2 = [],
     gridLoops_stroke = [],
     rectY = !0,
     ellipseY = !1,
     tri1Y = !1,
     tri2Y = !1,
     gradY = !1,
     space1Y = !1,
     space2Y = !1,
     smlRect = !1,
     smlEllipse = !1,
     rectGradY = !1;
const Y_AXIS = 1,
     X_AXIS = 2;
let b1, b2, c1, c2, myColRnd1, myColRnd2, myColRnd3, palSwitch;
var palette;

function setup() {
     const t = windowWidth < windowHeight ? windowWidth : windowHeight;
     createCanvas(t, t), blendMode(MULTIPLY), strokeCap(SQUARE), strokeThick = t / 300, offset = decPairs[1] <= 85 ? t / 3 : decPairs[1] > 85 && decPairs[1] <= 170 ? t / 4 : t / 2.5, countX = decPairs[2] <= 85 ? 0 : decPairs[2] > 85 && decPairs[2] < 170 ? 1 : 2, countX2 = decPairs[3] <= 85 ? 0 : 1, offsetH = offset, offsetHB = offsetB = t / 3, unit = floor(map(decPairs[4], 0, 255, 2, 6)), unit2 = floor(map(decPairs[5], 0, 255, 3, 6)), unit3 = floor(map(decPairs[6], 0, 255, 2, 7)), count = (t - offset) / unit, count2 = (t - offset) / unit2, count3 = (t - offsetB) / unit3, palSwitch = map(decPairs[10], 0, 255, 0, 1), palette = palSwitch <= .5 ? [color(244, 172, 20), color(241, 155, 194), color(177, 34, 35), color(69, 139, 151), color(190, 171, 138)] : [color("#3FB8AF"), color("#7FC7AF"), color("#DAD8A7"), color("#FF9E9D"), color("#FF3D7F"), color("#69D2E7"), color("#A7DBD8"), color("#E0E4CC"), color("#F38630"), color("#FA6900")], c1 = color(palette[int(R.random_between(0, palette.length))]), c2 = color(palette[int(R.random_between(0, palette.length))]);
     for (let t = 0; t < countX; t++) gridLoops1.push(new GridLooper(unit, unit, count, c1, c2));
     for (let t = 0; t < 1; t++) gridLoops2.push(new GridLooper(unit2, unit2, count2, c1, c2));
     for (let t = 0; t < countX2; t++) gridLoops_stroke.push(new GridLooper_stroke(unit3, unit3, count3, strokeThick));
     decPairs[7] <= 85 ? background(200) : decPairs[7] > 85 && decPairs[7] < 170 ? (background(palette[int(R.random_between(0, palette.length))]), fill(200, 50), noStroke(), rect(0, 0, innerWidth, innerHeight)) : background(palette[int(R.random_between(0, palette.length))]);
     for (let t = 0; t < gridLoops1.length; t++) gridLoops1[t].display();
     for (let t = 0; t < gridLoops2.length; t++) gridLoops2[t].display();
     for (let t = 0; t < gridLoops_stroke.length; t++) gridLoops_stroke[t].display()
}
class Random {
     constructor(t) {
          this.seed = t
     }
     random_dec() {
          return this.seed ^= this.seed << 13, this.seed ^= this.seed >> 17, this.seed ^= this.seed << 5, (this.seed < 0 ? 1 + ~this.seed : this.seed) % 1e3 / 1e3
     }
     random_between(t, e) {
          return t + (e - t) * this.random_dec()
     }
     random_int(t, e) {
          return Math.floor(this.random_between(t, e + 1))
     }
     random_choice(t) {
          return t[Math.floor(this.random_between(0, .99 * t.length))]
     }
}
let R = new Random(seed);

function setGradient(t, e, s, i, c, r, o) {
     if (noFill(), o === Y_AXIS)
          for (let o = e; o <= e + i; o++) {
               let l = map(o, e, e + i, 0, 1),
                    f = lerpColor(c, r, l);
               stroke(f), line(t, o, t + s, o)
          } else if (o === X_AXIS)
               for (let o = t; o <= t + s; o++) {
                    let l = map(o, t, t + s, 0, 1),
                         f = lerpColor(c, r, l);
                    stroke(f), line(o, e, o, e + i)
               }
}
class GridLooper {
     constructor(t, e, s, i, c) {
          this.k = t, this.l = e, this.c = s, this.rnd1 = i, this.rnd2 = c
     }
     display() {
          for (let t = 0; t < this.k; t++)
               for (let e = 0; e < this.l; e++) {
                    if (0 == (styleMaster = floor(R.random_between(0, 9))) ? (rectY = !0, ellipseY = !1, tri1Y = !1, tri2Y = !1, gradY = !1, space1Y = !1, space2Y = !1, smlRect = !1, smlEllipse = !1, rectGradY = !1) : 1 == styleMaster ? (rectY = !1, ellipseY = !0, tri1Y = !1, tri2Y = !1, gradY = !1, space1Y = !1, space2Y = !1, smlRect = !1, smlEllipse = !1, rectGradY = !1) : 2 == styleMaster ? (rectY = !1, ellipseY = !1, tri1Y = !0, tri2Y = !1, gradY = !1, space1Y = !1, space2Y = !1, smlRect = !1, smlEllipse = !1, rectGradY = !1) : 3 == styleMaster ? (rectY = !1, ellipseY = !1, tri1Y = !1, tri2Y = !0, gradY = !1, space1Y = !1, space2Y = !1, smlRect = !1, smlEllipse = !1, rectGradY = !1) : 4 == styleMaster ? (rectY = !1, ellipseY = !1, tri1Y = !1, tri2Y = !1, gradY = !0, space1Y = !1, space2Y = !1, smlRect = !1, smlEllipse = !1, rectGradY = !1) : 5 == styleMaster ? (rectY = !1, ellipseY = !1, tri1Y = !1, tri2Y = !1, gradY = !1, space1Y = !0, space2Y = !1, smlRect = !1, smlEllipse = !1, rectGradY = !1) : 6 == styleMaster ? (rectY = !1, ellipseY = !1, tri1Y = !1, tri2Y = !1, gradY = !1, space1Y = !1, space2Y = !0, smlRect = !1, smlEllipse = !1, rectGradY = !1) : 7 == styleMaster ? (rectY = !1, ellipseY = !1, tri1Y = !1, tri2Y = !1, gradY = !1, space1Y = !1, space2Y = !1, smlRect = !0, smlEllipse = !1, rectGradY = !1) : 8 == styleMaster ? (rectY = !1, ellipseY = !1, tri1Y = !1, tri2Y = !1, gradY = !1, space1Y = !1, space2Y = !1, smlRect = !1, smlEllipse = !0, rectGradY = !1) : 9 == styleMaster && (rectY = !1, ellipseY = !1, tri1Y = !1, tri2Y = !1, gradY = !1, space1Y = !1, space2Y = !1, smlRect = !1, smlEllipse = !1, rectGradY = !0), noStroke(), fill(palette[int(R.random_between(0, palette.length))]), rectY)
                         if (R.random_between(0, 1) <= .9) rect(t * this.c + offset / 2, e * this.c + offsetH / 2, this.c, this.c);
                         else if (R.random_between(0, 1) > .9 && R.random_between(0, 1) <= .99) setGradient(t * this.c + offset / 2, e * this.c + offsetH / 2, this.c, this.c, this.rnd1, this.rnd2, Y_AXIS);
                    else {
                         decPairs[9] <= 127.5 ? fill(0) : (blendMode(ADD), fill(255));
                         for (let s = 0; s < 20; s++) rect(t * this.c + offset / 2, e * this.c + offsetH / 2 + s * this.c / 20, this.c, this.c / 40);
                         blendMode(MULTIPLY)
                    }
                    ellipseY && (R.random_between(0, 1) < .9 ? ellipse(t * this.c + offset / 2 + this.c / 2, e * this.c + offsetH / 2 + this.c / 2, this.c, this.c) : (blendMode(ADD), fill(255), ellipse(t * this.c + offset / 2 + this.c / 2, e * this.c + offsetH / 2 + this.c / 2, this.c / 4, this.c / 4), blendMode(MULTIPLY))), tri1Y && (decPairs[11] <= 229.5 ? triangle(t * this.c + offset / 2, e * this.c + offsetH / 2 + this.c, t * this.c + offset / 2 + this.c, e * this.c + offsetH / 2, t * this.c + offset / 2 + this.c, e * this.c + offsetH / 2 + this.c) : triangle(t * this.c + offset / 2, e * this.c + offsetH / 2, t * this.c + offset / 2 + this.c, e * this.c + offsetH / 2, t * this.c + offset / 2, e * this.c + offsetH / 2 + this.c)), tri2Y && (decPairs[11] <= 229.5 ? triangle(t * this.c + offset / 2, e * this.c + offsetH / 2, t * this.c + offset / 2 + this.c, e * this.c + offsetH / 2, t * this.c + offset / 2 + this.c, e * this.c + offsetH / 2 + this.c) : triangle(t * this.c + offset / 2, e * this.c + offsetH / 2, t * this.c + offset / 2, e * this.c + offsetH / 2 + this.c, t * this.c + offset / 2 + this.c, e * this.c + offsetH / 2 + this.c)), gradY && (R.random_between(0, 1) < .5 ? setGradient(t * this.c + offset / 2, e * this.c + offsetH / 2, this.c / 2, this.c, this.rnd1, this.rnd2, Y_AXIS) : setGradient(t * this.c + offset / 2, e * this.c + offsetH / 2, this.c / 2, this.c / 2, this.rnd2, this.rnd1, Y_AXIS))
               }
     }
}
class GridLooper_stroke {
     constructor(t, e, s, i) {
          this.k = t, this.l = e, this.c = s, this.sw = i
     }
     display() {
          for (let t = 0; t < this.k; t++)
               for (let e = 0; e < this.l; e++) 0 == (styleMaster = floor(R.random_between(0, 6))) ? (rectY = !0, ellipseY = !1, tri1Y = !1, tri2Y = !1, space1Y = !1, space2Y = !1) : 1 == styleMaster ? (rectY = !1, ellipseY = !0, tri1Y = !1, tri2Y = !1, space1Y = !1, space2Y = !1) : 2 == styleMaster ? (rectY = !1, ellipseY = !1, tri1Y = !0, tri2Y = !1, space1Y = !1, space2Y = !1) : 3 == styleMaster ? (rectY = !1, ellipseY = !1, tri1Y = !1, tri2Y = !0, space1Y = !1, space2Y = !1) : 4 == styleMaster ? (rectY = !1, ellipseY = !1, tri1Y = !1, tri2Y = !1, space1Y = !0, space2Y = !1) : 5 == styleMaster && (rectY = !1, ellipseY = !1, tri1Y = !1, tri2Y = !1, space1Y = !1, space2Y = !0), noFill(), strokeWeight(this.sw), decPairs[8] <= 127.5 ? (blendMode(ADD), stroke(255)) : stroke(0), rectY && rect(t * this.c + offsetB / 2, e * this.c + offsetHB / 2, this.c, this.c), ellipseY && ellipse(t * this.c + offsetB / 2 + this.c / 2, e * this.c + offsetHB / 2 + this.c / 2, this.c, this.c), tri1Y && (decPairs[11] <= 229.5 ? triangle(t * this.c + offsetB / 2, e * this.c + offsetHB / 2 + this.c, t * this.c + offsetB / 2 + this.c, e * this.c + offsetHB / 2, t * this.c + offsetB / 2 + this.c, e * this.c + offsetHB / 2 + this.c) : triangle(t * this.c + offsetB / 2, e * this.c + offsetHB / 2, t * this.c + offsetB / 2 + this.c, e * this.c + offsetHB / 2, t * this.c + offsetB / 2, e * this.c + offsetHB / 2 + this.c)), tri2Y && (decPairs[11] <= 229.5 ? triangle(t * this.c + offsetB / 2, e * this.c + offsetHB / 2, t * this.c + offsetB / 2 + this.c, e * this.c + offsetHB / 2, t * this.c + offsetB / 2 + this.c, e * this.c + offsetHB / 2 + this.c) : triangle(t * this.c + offsetB / 2, e * this.c + offsetHB / 2, t * this.c + offsetB / 2, e * this.c + offsetHB / 2 + this.c, t * this.c + offsetB / 2 + this.c, e * this.c + offsetHB / 2 + this.c)), blendMode(MULTIPLY)
     }
}
    </script>
  </body>
</html>
