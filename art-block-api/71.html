<html><body><h1>Name: Andradite</h1><h3>Artist: Eltono</h3><h3>Description: Andradite comes from the transposition of my Modo7 protocol into sculptures. Heavy brutalist shapes that come together to create dark monolithic structures half way between sculpted objects and troglodytic architecture. The name of the script comes from the andradite, a stone which crystallizes following cubic patterns and can be found in deep dark color. The gradient backgrounds create depth and mood and recall the way they showcase the stones in professional mineral photographs.</h3><h3>https://www.eltono.com/lab/projects/andradite/</h3><hr/><p>Script JSON: {&quot;type&quot;:&quot;p5js&quot;,&quot;aspectRatio&quot;:&quot;1/1&quot;}</p><p>Script Type: p5js</p><p>Version: </p><p>Script Ratio: 1/1</p><p>Instructions: </p><p>Hashes Generated per Token: true</p><p>Dynamic Asset? true</p><hr/><p>Artist Ethereum Address: 0x54fcfccdcaabd65e107a33edfc0e83ee2c621ec0</p><p>Additional Payee: 0x4ba4f8a7e91bb212a13a510350771824cd12123a</p><p>Additional Payee Percentage: 20</p><p>Price: 0.1</p><p>Currency: ETH</p><p>Currency Address: N/A</p><p>Invocations: 222</p><p>Maximum Invocations: 222</p><p>License: CC BY-NC 4.0</p><p>Token Ids: 71000000,71000001,71000002,71000003,71000004,71000005,71000006,71000007,71000008,71000009,71000010,71000011,71000012,71000013,71000014,71000015,71000016,71000017,71000018,71000019,71000020,71000021,71000022,71000023,71000024,71000025,71000026,71000027,71000028,71000029,71000030,71000031,71000032,71000033,71000034,71000035,71000036,71000037,71000038,71000039,71000040,71000041,71000042,71000043,71000044,71000045,71000046,71000047,71000048,71000049,71000050,71000051,71000052,71000053,71000054,71000055,71000056,71000057,71000058,71000059,71000060,71000061,71000062,71000063,71000064,71000065,71000066,71000067,71000068,71000069,71000070,71000071,71000072,71000073,71000074,71000075,71000076,71000077,71000078,71000079,71000080,71000081,71000082,71000083,71000084,71000085,71000086,71000087,71000088,71000089,71000090,71000091,71000092,71000093,71000094,71000095,71000096,71000097,71000098,71000099</p><p>Active? true</p><p>Paused? false</p><hr/><p><strong>Script:</strong></p><pre>let txnbpointV = 2,
     txnbpointH = 1,
     txnbsegment = &quot;6,7&quot;,
     txnbfigure = &quot;2&quot;,
     txnbcol = 3,
     txepais = 0,
     txlargeur = 2e3,
     txhauteur = 2e3,
     txnblig = 2,
     txcoltrait = &quot;#BFE2D0&quot;,
     txQuadEp = 6,
     txEpaisSurl = 10,
     txDecal = &quot;124,-124&quot;,
     txMG = 84,
     txMD = 84,
     txMH = 84,
     txMB = 84,
     txMI = 300,
     txArrondi = 100,
     textarea1 = new Array(73);

function load_textarea1() {
     textarea1[0] = &quot;#080a23*1*1*R**night-blue&quot;, textarea1[1] = &quot;#080a23*1*2*R**night-blue&quot;, textarea1[2] = &quot;#e0d5ce*1*1*R*CLAIR*off-white&quot;, textarea1[3] = &quot;#e0d5ce*1*2*R*CLAIR*off-white&quot;, textarea1[4] = &quot;#44ffb900-#440fc4a0*3**FDH**&quot;, textarea1[5] = &quot;#44ffb900-#440fc4a0*3**FDV**&quot;, textarea1[6] = &quot;#440fc4a0-#44ffb900*3**FDH**&quot;, textarea1[7] = &quot;#440fc4a0-#44ffb900*3**FDV**&quot;, textarea1[8] = &quot;#44e27824-#4423084b*3**FDH**&quot;, textarea1[9] = &quot;#44e27824-#4423084b*3**FDV**&quot;, textarea1[10] = &quot;#4423084b-#44e27824*3**FDH**&quot;, textarea1[11] = &quot;#4423084b-#44e27824*3**FDV**&quot;, textarea1[13] = &quot;#4b4148-#080a23*1**FDV*FFONCE*&quot;, textarea1[14] = &quot;#00ff00*1**Q*FFONCE*&quot;, textarea1[12] = &quot;#fffc8a-#fff000*1**FDV**&quot;, textarea1[15] = &quot;#ffffff*1*1*S**&quot;, textarea1[16] = &quot;#ffffff*1*2*S**&quot;, textarea1[17] = &quot;#080a23*1*1*S*CLAIR*&quot;, textarea1[18] = &quot;#080a23*1*2*S*CLAIR*&quot;, textarea1[19] = &quot;#B3ffffff*1**Q**&quot;, textarea1[20] = &quot;#4D080a23*1**Q**&quot;, textarea1[21] = &quot;#b14254-#355c7a*1**MDH**&quot;, textarea1[22] = &quot;#b14254-#355c7a*1**MDV**&quot;, textarea1[23] = &quot;#355c7a-#b14254*1**MDH**&quot;, textarea1[24] = &quot;#355c7a-#b14254*1**MDV**&quot;, textarea1[25] = &quot;#590c3877-#5900b290*2**MDH**&quot;, textarea1[26] = &quot;#590c3877-#5900b290*2**MDV**&quot;, textarea1[27] = &quot;#5900b290-#590c3877*2**MDH**&quot;, textarea1[28] = &quot;#5900b290-#590c3877*2**MDV**&quot;, textarea1[29] = &quot;#ffe888-#54b5a3*1**MDH**&quot;, textarea1[30] = &quot;#ffe888-#54b5a3*1**MDV**&quot;, textarea1[31] = &quot;#54b5a3-#ffe888*1**MDH**&quot;, textarea1[32] = &quot;#54b5a3-#ffe888*1**MDV**&quot;, textarea1[33] = &quot;#59cd924a-#5954b5a3*2**MDH**&quot;, textarea1[34] = &quot;#59cd924a-#5954b5a3*2**MDV**&quot;, textarea1[35] = &quot;#5954b5a3-#59cd924a*2**MDH**&quot;, textarea1[36] = &quot;#5954b5a3-#59cd924a*2**MDV**&quot;, textarea1[37] = &quot;#BFe27824-#23084b*1**MDV**&quot;, textarea1[38] = &quot;#BFe27824-#23084b*1**MDH**&quot;, textarea1[39] = &quot;#23084b-#BFe27824*1**MDV**&quot;, textarea1[40] = &quot;#23084b-#BFe27824*1**MDH**&quot;, textarea1[41] = &quot;#59e27824-#5923084b*2**MDV**&quot;, textarea1[42] = &quot;#59e27824-#5923084b*2**MDH**&quot;, textarea1[43] = &quot;#5923084b-#59e27824*2**MDV**&quot;, textarea1[44] = &quot;#5923084b-#59e27824*2**MDH**&quot;, textarea1[45] = &quot;#9ab18a-#9a365d*1**MDV**&quot;, textarea1[46] = &quot;#9a365d-#9ab18a*1**MDH**&quot;, textarea1[47] = &quot;#9a365d-#9ab18a*1**MDV**&quot;, textarea1[48] = &quot;#9ab18a-#9a365d*1**MDH**&quot;, textarea1[49] = &quot;#599ab18a-#599a365d*2**MDV**&quot;, textarea1[50] = &quot;#599a365d-#599ab18a*2**MDH**&quot;, textarea1[51] = &quot;#599a365d-#599ab18a*2**MDV**&quot;, textarea1[52] = &quot;#599ab18a-#599a365d*2**MDH**&quot;, textarea1[53] = &quot;#BFe27824-#23084b*1**MDV*CLAIR*&quot;, textarea1[54] = &quot;#BFe27824-#23084b*1**MDH*CLAIR*&quot;, textarea1[55] = &quot;#23084b-#BFe27824*1**MDV*CLAIR*&quot;, textarea1[56] = &quot;#23084b-#BFe27824*1**MDH*CLAIR*&quot;, textarea1[57] = &quot;#6d1e3a-#984527*1**MDV*CLAIR*&quot;, textarea1[58] = &quot;#984527-#6d1e3a*1**MDH*CLAIR*&quot;, textarea1[59] = &quot;#984527-#6d1e3a*1**MDV*CLAIR*&quot;, textarea1[60] = &quot;#6d1e3a-#984527*1**MDH*CLAIR*&quot;, textarea1[61] = &quot;#17062d-#6d1e37*1**MDV*CLAIR*&quot;, textarea1[62] = &quot;#6d1e37-#17062d*1**MDH*CLAIR*&quot;, textarea1[63] = &quot;#6d1e37-#17062d*1**MDV*CLAIR*&quot;, textarea1[64] = &quot;#17062d-#6d1e37*1**MDH*CLAIR*&quot;, textarea1[65] = &quot;#1f4056-#080a23*1**MDV*CLAIR*&quot;, textarea1[66] = &quot;#1f4056-#080a23*1**MDH*CLAIR*&quot;, textarea1[67] = &quot;#080a23-#1f4056*1**MDV*CLAIR*&quot;, textarea1[68] = &quot;#080a23-#1f4056*1**MDH*CLAIR*&quot;, textarea1[69] = &quot;#684949-#3e4952*1**MDV*CLAIR*&quot;, textarea1[70] = &quot;#684949-#3e4952*1**MDH*CLAIR*&quot;, textarea1[71] = &quot;#3e4952-#684949*1**MDV*CLAIR*&quot;, textarea1[72] = &quot;#3e4952-#684949*1**MDH*CLAIR*&quot;
}
class Random {
     constructor(e) {
          this.seed = e
     }
     random_dec() {
          return this.seed ^= this.seed &lt;&lt; 13, this.seed ^= this.seed &gt;&gt; 17, this.seed ^= this.seed &lt;&lt; 5, (this.seed &lt; 0 ? 1 + ~this.seed : this.seed) % 1e3 / 1e3
     }
     random_between(e, t) {
          return e + (t - e) * this.random_dec()
     }
     random_int(e, t) {
          return Math.floor(this.random_between(e, t + 1))
     }
     random_choice(e) {
          return e[Math.floor(this.random_between(0, .99 * e.length))]
     }
}
let seed = parseInt(tokenData.hash.slice(0, 16), 16),
     R = new Random(seed),
     done = !1,
     couleurs_surlig = new Array(0),
     couleurs_marge = new Array(0),
     couleurs_quad = new Array(0),
     couleurs_remp = new Array(0),
     couleurs_trait = new Array(0),
     couleurs_fond = new Array(0),
     grpcouleurs = new Array(0),
     degCold = 0,
     degColf = 0,
     degrad = &quot;&quot;,
     ok = !1,
     numOrd = 0,
     pash = 0,
     pasl = 0,
     pointsx = new Array(0),
     pointsy = new Array(0),
     nordres = new Array(0),
     nordre = 0,
     xpoint = 0,
     ypoint = 0,
     M = 0,
     grRetour = &quot;&quot;;

function setup() {
     var e = txhauteur + txMH + txMB + 2 * txMI,
          t = window.innerWidth,
          r = window.innerHeight,
          a = Math.min(t, r);
     M = a / e, txlargeur = int(M * txlargeur), txhauteur = int(M * txhauteur), txMD = int(M * txMD), txMG = int(M * txMG), txMH = int(M * txMH), txMB = int(M * txMB), txMI = int(M * txMI), txArrondi = int(M * txArrondi), txepais *= M, txEpaisSurl *= M, txQuadEp *= M, load_textarea1(), createCanvas(txlargeur + txMD + txMG + 2 * txMI, txhauteur + txMH + txMB + 2 * txMI, P2D), noLoop()
}

function draw() {
     if (1 == done);
     else {
          done = !0;
          let e = int(R.random_between(0, 100));
          grpcouleurs[0] = e &lt;= 90 ? &quot;&quot; : &quot;CLAIR&quot;;
          let t = color(&quot;#fff5e1&quot;);
          background(t), smooth(), noStroke(), pash = txhauteur / txnblig, pasl = txlargeur / txnbcol, colorMode(RGB);
          let r = split(trim(txnbfigure), &quot;,&quot;),
               a = r[0],
               n = split(trim(txnbsegment), &quot;,&quot;),
               o = n[0],
               l = txMI,
               x = &quot;0&quot;;
          x = &quot;0&quot;;
          let u = &quot;&quot;;
          for (let e = 0; e &lt; textarea1.length; e += 1) {
               let t = split(textarea1[e], &quot;*&quot;),
                    r = int(t[1]);
               for (u = t[3].toUpperCase(); r &gt; 0;) {
                    switch (u) {
                         case &quot;&quot;:
                              couleurs_marge.push(textarea1[e]), couleurs_quad.push(textarea1[e]), couleurs_trait.push(textarea1[e]), couleurs_surlig.push(textarea1[e]), couleurs_remp.push(textarea1[e]), couleurs_fond.push(textarea1[e]);
                              break;
                         case &quot;M&quot;:
                         case &quot;MDH&quot;:
                         case &quot;MDV&quot;:
                              couleurs_marge.push(textarea1[e]);
                              break;
                         case &quot;Q&quot;:
                              couleurs_quad.push(textarea1[e]);
                              break;
                         case &quot;T&quot;:
                              couleurs_trait.push(textarea1[e]);
                              break;
                         case &quot;S&quot;:
                              couleurs_surlig.push(textarea1[e]);
                              break;
                         case &quot;R&quot;:
                              couleurs_remp.push(textarea1[e]);
                              break;
                         case &quot;F&quot;:
                         case &quot;FDH&quot;:
                         case &quot;FDV&quot;:
                              couleurs_fond.push(textarea1[e])
                    }
                    r -= 1
               }
          }
          couleurs_marge = scramble(couleurs_marge), couleurs_quad = scramble(couleurs_quad), couleurs_trait = scramble(couleurs_trait), couleurs_surlig = scramble(couleurs_surlig), couleurs_remp = scramble(couleurs_remp), couleurs_fond = scramble(couleurs_fond), noStroke();
          let s = txlargeur + 2 * txMI,
               i = txhauteur + 2 * txMI,
               d = 0,
               c = int(R.random_between(0, couleurs_marge.length));
          d = getCouleurs(c, 999, !0, &quot;M&quot;, grpcouleurs[0]), &quot;V&quot; == degrad || &quot;H&quot; == degrad ? (coldegrad(txMG, txMH, s, i, txArrondi, degrad), noFill()) : fill(d);
          let b = round(txArrondi / 3 + 1);
          strokeWeight(b), stroke(t), mod = rect(txMG - b / 2, txMH - b / 2, s + b, i + b, txArrondi), noStroke(), blendMode(BLEND);
          let p = int(split(trim(txDecal), &quot;,&quot;)),
               f = txMG + txMI,
               g = txMH + txMI,
               h = txlargeur,
               D = txhauteur,
               H = h / txnbcol,
               _ = D / txnblig,
               A = getCouleurs(c = int(R.random_between(0, couleurs_fond.length)), 999, !1, &quot;F&quot;, grpcouleurs[0]);
          grpcouleurs[1] = grRetour, &quot;V&quot; == degrad || &quot;H&quot; == degrad ? (coldegrad(f, g, h, D, 0, degrad), noFill()) : fill(A), mod = rect(f, g, h, D);
          let m = new Array(0),
               C = new Array(0);
          for (let e = 0; e &lt; txnbcol + 1; e += 1) m.push(e * pasl);
          for (let e = 0; e &lt; txnblig + 1; e += 1) C.push(e * pash);
          quadri(m, C, f, g, H, _);
          let I = new Array(0),
               V = new Array(0),
               w = new Array(0),
               k = new Array(0);
          nordre = 0, xpoint = pasl / (txnbpointH + 1), ypoint = pash / (txnbpointV + 1);
          for (let e = 0; e &lt; txnbpointH + 2; e += 1) {
               appendXY(e, 0, txnbpointH + 1, txnbpointV + 1)
          }
          for (let e = 0; e &lt; txnbpointV + 2; e += 1) {
               appendXY(txnbpointH + 1, e, txnbpointH + 1, txnbpointV + 1)
          }
          for (let e = txnbpointH + 1; e &gt; -1; e -= 1) {
               appendXY(e, txnbpointV + 1, txnbpointH + 1, txnbpointV + 1)
          }
          for (let e = txnbpointV + 1; e &gt;= 0; e -= 1) {
               appendXY(0, e, txnbpointH + 1, txnbpointV + 1)
          }
          strokeCap(ROUND), strokeJoin(ROUND), a = r[int(R.random_between(0, r.length))];
          for (let e = 0; e &lt; a; e += 1) {
               blendMode(BLEND), txMI = l, e &lt; p.length &amp;&amp; (txMI += p[e] * M), V = new Array(0), w = new Array(0), k = new Array(0);
               for (let t = 0; t &lt; txnbcol; t += 1)
                    for (let r = 0; r &lt; txnblig; r += 1) {
                         let a = int(R.random_between(couleurs_remp.length));
                         if (fill(getCouleurs(a, e, !0, &quot;R&quot;, grpcouleurs[0])), 0 != txepais) {
                              let e = traiteCouleurs(txcoltrait);
                              stroke(e), strokeWeight(txepais)
                         }
                         nordres = scramble(nordres), I = new Array(0), o = n[int(R.random_between(0, n.length))];
                         for (let e = 0; e &lt; int(o) + 1; e += 1) I.push(nordres[e]);
                         I.sort(function(e, t) {
                              return e - t
                         }), beginShape();
                         let l = o;
                         k.push(l);
                         for (let e = 0; e &lt; l; e += 1) {
                              let a = pointsx[I[e]],
                                   n = pointsy[I[e]],
                                   o = int(a + txMG + txMI + m[t]),
                                   l = int(n + txMH + txMI + C[r]);
                              vertex(o, l), V.push(o), w.push(l)
                         }
                         endShape(CLOSE)
                    }
               surligner(V, w, k, e), V = new Array(0), w = new Array(0), k = new Array(0)
          }
     }
}

function appendXY(e, t, r, a) {
     e == r ? pointsx.push(pasl) : pointsx.push(e * xpoint), t == a ? pointsy.push(pash) : pointsy.push(t * ypoint), nordres.push(nordre), nordre += 1
}

function scramble(e) {
     let t = [],
          r = e.length;
     for (let a = 0; a &lt; r; a++) {
          let r = floor(map(R.random_dec(), 0, 1, 0, e.length));
          t.push(e[r]), e.splice(r, 1)
     }
     return t
}

function surligner(e, t, r, a) {
     strokeWeight(txEpaisSurl);
     let n = 0,
          o = 0,
          l = 0;
     a -= 1;
     let x = 0;
     for (let u = 0; u &lt; e.length; u += 1) {
          let s = e[u],
               i = t[u],
               d = 0;
          o == l ? (l = r[n], d = u + int(l) - 1, n % (txnbcol * txnblig) == 0 &amp;&amp; (x = getCouleurs(0, a += 1, !0, &quot;S&quot;, grpcouleurs[0])), n += 1, o = 0) : d = u - 1, o += 1;
          let c = e[d],
               b = t[d];
          c != s &amp;&amp; b != i &amp;&amp; ok &amp;&amp; (stroke(x), line(c, b, s, i))
     }
     noStroke()
}

function quadri(e, t, r, a, n, o) {
     let l = getCouleurs(int(R.random_between(0, couleurs_quad.length)), 999, !0, &quot;Q&quot;, grpcouleurs[1]);
     stroke(l), strokeWeight(txQuadEp);
     let x = n / (int(txnbpointH) + 1),
          u = o / (int(txnbpointV) + 1),
          s = t[txnblig] + txMH + txMI,
          i = e[txnbcol] + txMG + txMI,
          d = a,
          c = r;
     for (let e = 1; e &lt; txnbcol * (int(txnbpointH) + 1); e += 1) line(r + e * x, d, r + e * x, s);
     line(r, a, r, t[txnblig] + txMH + txMI), line(e[txnbcol] + txMG + txMI, a, e[txnbcol] + txMG + txMI, t[txnblig] + txMH + txMI);
     for (let e = 1; e &lt; txnblig * (int(txnbpointV) + 1); e += 1) line(c, a + e * u, i, a + e * u);
     line(r, a, e[txnbcol] + txMG + txMI, a), line(r, t[txnblig] + txMH + txMI, e[txnbcol] + txMG + txMI, t[txnblig] + txMH + txMI), noStroke()
}

function traiteCouleurs(e) {
     let t = 0,
          r = splitTokens(e, &quot;, &quot;);
     switch (r.length) {
          case 1:
               if (&quot;#&quot; == r[0].substring(0, 1)) {
                    if (7 == r[0].length) {
                         let e = unhex(r[0].substring(1, 3)),
                              a = unhex(r[0].substring(3, 5)),
                              n = unhex(r[0].substring(5));
                         t = color(e, a, n)
                    }
                    if (9 == r[0].length) {
                         let e = unhex(r[0].substring(1, 3)),
                              a = unhex(r[0].substring(3, 5)),
                              n = unhex(r[0].substring(5, 7)),
                              o = unhex(r[0].substring(7));
                         t = color(a, n, o, e)
                    }
               } else t = int(r[0]);
               break;
          case 2:
               t = color(int(r[0]), int(r[1]));
               break;
          case 3:
               t = color(int(r[0]), int(r[1]), int(r[2]));
               break;
          case 4:
               t = color(int(r[0]), int(r[1]), int(r[2]), int(r[3]))
     }
     return t
}

function getCouleurs(e, t, r, a, n) {
     let o = new Array(0);
     switch (a) {
          case &quot;M&quot;:
               o = couleurs_marge.copyWithin(0);
               break;
          case &quot;Q&quot;:
               o = couleurs_quad.copyWithin(0);
               break;
          case &quot;T&quot;:
               o = couleurs_trait.copyWithin(0);
               break;
          case &quot;S&quot;:
               o = couleurs_surlig.copyWithin(0);
               break;
          case &quot;R&quot;:
               o = couleurs_remp.copyWithin(0);
               break;
          case &quot;F&quot;:
               o = couleurs_fond.copyWithin(0)
     }
     degrad = &quot;&quot;;
     let l, x = !1,
          u = !1,
          s = 0,
          i = &quot;&quot;;
     for (; 0 == x;) i = e + s &lt; o.length ? o[e + s] : o[0], l = split(i, &quot;*&quot;), 0 == r ? (x = !0, ok = !0) : int(l[2]) != t + 1 &amp;&amp; 999 != t || l[4] == n &amp;&amp; (ok = !0, x = !0), e + s &lt; o.length - 1 ? s += 1 : (1 == u &amp;&amp; (x = !0, ok = !0), s = 0 - e, u = !0);
     grRetour = l[4];
     let d = l[0],
          c = 0,
          b = split(d, &quot;-&quot;);
     if (void 0 === b[1]) c = traiteCouleurs(b[0]);
     else {
          c = color(255, 255, 255);
          let e = traiteCouleurs(b[0]),
               t = traiteCouleurs(b[1]);
          if (&quot;DV&quot; == l[3].substring(1) || &quot;DH&quot; == l[3].substring(1)) degCold = e, degColf = t, degrad = l[3].substring(2);
          else {
               let r = R.random_between(0, 100) / 100;
               c = lerpColor(e, t, r)
          }
     }
     return c
}

function coldegrad(e, t, r, a, n, o) {
     if (e = round(e), t = round(t), r = round(r), a = round(a), n = round(n), beginShape(), noStroke(), &quot;V&quot; == o)
          for (let n = 0; n &lt; a; n += 1) {
               let o = map(n, 0, a, 0, 1),
                    l = lerpColor(degCold, degColf, o);
               fill(l), rect(e, n + t, r, 1)
          } else
               for (let n = 0; n &lt; r; n += 1) {
                    let o = map(n, 0, r, 0, 1),
                         l = lerpColor(degCold, degColf, o);
                    fill(l), rect(n + e, t, 1, a)
               }
     endShape()
}</pre></body></html>