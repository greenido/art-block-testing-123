<html><body><h1>Name: Galaxiss</h1><h3>Artist: Xenoliss</h3><h3>Description: As the first on chain generative planets, I present my Galaxiss project. Each planet uses several layers of complex noises to generate nearly infinite variations of terrain, shapes, and biomes. Check out the lost airplane that has been signaled flying around and if you're lucky you might even catch another surprise chopper! Collect planets and build the Galaxiss of your dream!

p/h: attach to airplane/chopper - n: toggle night mode (if available) - digit keys left to right on the keyboard (1, 2, 3, [...], 9, 0): change resolution (1 being the minimum and 0 the maximum) - space bar: pause/unpause the world - pinch to zoom (on smartphones) - triple fingers touch: switch between vehicles (on smartphones)</h3><h3>https://twitter.com/Xenoliss</h3><hr/><p>Script JSON: {&quot;aspectRatio&quot;:&quot;1&quot;,&quot;type&quot;:&quot;threejs&quot;,&quot;instructions&quot;:&quot;Wheel: zoom/unzoom | Mouse drag: rotate the planet | Space bar: pause/unpause the world | 'n': toggle night mode if allowed | 'p': attach to airplane | 'h': attach to chopper | Digit keys (left to right on the keyboard: 1, 2 [...], 9, 0): change the planet resolution (1 key being the minimum, then 2 etc. up to 0 key for the maximum resolution) | pinch: zoom/unzoom | triple fingers touch: switch between vehicles&quot;,&quot;animationLengthInSeconds&quot;:&quot;10&quot;,&quot;interactive&quot;:&quot;true&quot;}</p><p>Script Type: threejs</p><p>Version: </p><p>Script Ratio: 1</p><p>Instructions: Wheel: zoom/unzoom | Mouse drag: rotate the planet | Space bar: pause/unpause the world | 'n': toggle night mode if allowed | 'p': attach to airplane | 'h': attach to chopper | Digit keys (left to right on the keyboard: 1, 2 [...], 9, 0): change the planet resolution (1 key being the minimum, then 2 etc. up to 0 key for the maximum resolution) | pinch: zoom/unzoom | triple fingers touch: switch between vehicles</p><p>Hashes Generated per Token: true</p><p>Dynamic Asset? true</p><hr/><p>Artist Ethereum Address: 0x203e480da98eef38526dce30a798b02a65fa6938</p><p>Additional Payee: 0x0000000000000000000000000000000000000000</p><p>Additional Payee Percentage: 0</p><p>Price: 0.15</p><p>Currency: ETH</p><p>Currency Address: N/A</p><p>Invocations: 600</p><p>Maximum Invocations: 600</p><p>License: CC BY-NC 4.0</p><p>Token Ids: 31000000,31000001,31000002,31000003,31000004,31000005,31000006,31000007,31000008,31000009,31000010,31000011,31000012,31000013,31000014,31000015,31000016,31000017,31000018,31000019,31000020,31000021,31000022,31000023,31000024,31000025,31000026,31000027,31000028,31000029,31000030,31000031,31000032,31000033,31000034,31000035,31000036,31000037,31000038,31000039,31000040,31000041,31000042,31000043,31000044,31000045,31000046,31000047,31000048,31000049,31000050,31000051,31000052,31000053,31000054,31000055,31000056,31000057,31000058,31000059,31000060,31000061,31000062,31000063,31000064,31000065,31000066,31000067,31000068,31000069,31000070,31000071,31000072,31000073,31000074,31000075,31000076,31000077,31000078,31000079,31000080,31000081,31000082,31000083,31000084,31000085,31000086,31000087,31000088,31000089,31000090,31000091,31000092,31000093,31000094,31000095,31000096,31000097,31000098,31000099</p><p>Active? true</p><p>Paused? false</p><hr/><p><strong>Script:</strong></p><pre>(() =&gt; {
     &quot;use strict&quot;;
     const e = THREE,
          t = 4095;
     let l = 4,
          n = .5;
     const i = e =&gt; .5 * (1 - Math.cos(e * Math.PI));
     let r;
     const s = function(e, s = 0, o = 0) {
               if (null == r) {
                    r = new Array(4096);
                    for (let e = 0; e &lt; 4096; e++) r[e] = Math.random()
               }
               e &lt; 0 &amp;&amp; (e = -e), s &lt; 0 &amp;&amp; (s = -s), o &lt; 0 &amp;&amp; (o = -o);
               let a, c, u, h, p, d = Math.floor(e),
                    _ = Math.floor(s),
                    w = Math.floor(o),
                    f = e - d,
                    E = s - _,
                    S = o - w,
                    N = 0,
                    T = .5;
               for (let e = 0; e &lt; l; e++) {
                    let e = d + (_ &lt;&lt; 4) + (w &lt;&lt; 8);
                    a = i(f), c = i(E), u = r[e &amp; t], u += a * (r[e + 1 &amp; t] - u), h = r[e + 16 &amp; t], h += a * (r[e + 16 + 1 &amp; t] - h), u += c * (h - u), e += 256, h = r[e &amp; t], h += a * (r[e + 1 &amp; t] - h), p = r[e + 16 &amp; t], p += a * (r[e + 16 + 1 &amp; t] - p), h += c * (p - h), u += i(S) * (h - u), N += u * T, T *= n, d &lt;&lt;= 1, f *= 2, _ &lt;&lt;= 1, E *= 2, w &lt;&lt;= 1, S *= 2, f &gt;= 1 &amp;&amp; (d++, f--), E &gt;= 1 &amp;&amp; (_++, E--), S &gt;= 1 &amp;&amp; (w++, S--)
               }
               return N
          },
          o = function(e, t) {
               e &gt; 0 &amp;&amp; (l = e), t &gt; 0 &amp;&amp; (n = t)
          },
          a = function(e) {
               const t = (() =&gt; {
                    const e = 4294967296;
                    let t, l;
                    return {
                         t(n) {
                              l = t = (null == n ? Math.random() * e : n) &gt;&gt;&gt; 0
                         },
                         l: () =&gt; t,
                         i: () =&gt; (l = (1664525 * l + 1013904223) % e, l / e)
                    }
               })();
               t.t(e), r = new Array(4096);
               for (let e = 0; e &lt; 4096; e++) r[e] = t.i()
          };
     var c = window,
          u = document,
          h = u.createElement(&quot;meta&quot;);

     function p(e, t, l) {
          let n = e / (t[1] - t[0]);
          return l[0] + n * (l[1] - l[0])
     }

     function d() {
          return x.o &gt; .8
     }

     function _() {
          return x.u &gt; .85
     }

     function w() {
          return x.h &gt; .9
     }

     function f(e) {
          for (let t of e.children) t.receiveShadow = !0
     }

     function E(e, t, l, n, i, r) {
          (y = new e(16777215, t)).castShadow = !0, y.position.set(n, i, r), y.target.position.set(0, 0, 0), y.shadow.mapSize.width = 4096, y.shadow.mapSize.height = 4096, y.shadow.camera.near = 1, y.shadow.camera.p = 200, y.shadow.bias = -5e-4, (M = new e(16777215, l)).castShadow = !1, M.position.set(n, i, r), M.target.position.set(0, 0, 0), B ? (y.angle = Math.PI / 6.5, y.penumbra = 1, y.decay = 2.5, M.angle = Math.PI / 6.5, M.penumbra = 1, M.distance = 130, M.decay = 2.5, C._ = 0) : (y.shadow.camera.right = 100, y.shadow.camera.left = -100, y.shadow.camera.top = 100, y.shadow.camera.bottom = -100, C._ = .1), H.add(M), H.add(y)
     }

     function S() {
          B ? E(e.SpotLight, .5, 2 == b ? 2.3 : 2.8, 0, 0, 100) : E(e.DirectionalLight, .4, 2 == b ? .5 : .6, -60, 60, 60), H.add(C)
     }

     function N() {
          let t = B ? 1 : 0,
               l = (new e.Color).copy(k[b][0]);
          P.setClearColor(l.multiplyScalar(G[b][t]))
     }

     function T(e) {
          let t = e * v;
          return t ^= t &lt;&lt; 13, t ^= t &gt;&gt; 17, t ^= t &lt;&lt; 5, (t &lt; 0 ? 1 + ~t : t) % 1e3 / 1e3
     }
     h.name = &quot;viewport&quot;, h.content = &quot;width=device-width, initial-scale=1.0&quot;, u.getElementsByTagName(&quot;head&quot;)[0].appendChild(h);
     var y, M, L = (t, l, n) =&gt; new e.Vector3(t, l, n),
          m = (t, l) =&gt; new e.Vector2(t, l),
          A = (t, l, n) =&gt; new e.BoxGeometry(t, l, n),
          D = (t, l) =&gt; new e.Mesh(t, l),
          g = (t, l, n) =&gt; ((t, l, n) =&gt; new e.Color(t, l, n))(t / 255, l / 255, n / 255),
          z = e.MeshPhongMaterial,
          F = Event,
          I = CustomEvent,
          x = {
               S: 0,
               N: 0,
               T: 0,
               M: 0,
               L: 0,
               m: 0,
               A: 0,
               D: 0,
               F: 0,
               I: 0,
               O: 0,
               v: 0,
               R: 0,
               u: 0,
               o: 0,
               H: 0,
               h: 0
          },
          O = {
               S: [0, 1, 0, 1],
               N: [2, 3, 0, 1],
               T: [4, 5, 0, 1],
               M: [8, 9, 16, 20],
               L: [10, 11, .32, .44],
               m: [12, 13, .07, .1],
               A: [14, 14, 0, .4],
               D: [15, 16, .22, .25],
               F: [17, 18, 1.5, 2.8],
               I: [25, 26, 0, 1],
               O: [1, 1, 1.05, 1.1],
               v: [2, 2, 4, 10],
               R: [0, 0, 0, 1],
               u: [19, 20, 0, 1],
               o: [6, 7, 0, 1],
               H: [27, 27, 0, 6],
               h: [30, 31, 0, 1]
          },
          b = 0,
          v = 1e6,
          R = 75,
          H = new e.Scene,
          P = function() {
               let t = new e.WebGLRenderer({
                    antialias: !0,
                    alpha: !0
               });
               return t.setPixelRatio(c.devicePixelRatio), t.setSize(c.innerWidth, c.innerHeight), t.shadowMap.enabled = !0, t.shadowMap.type = e.VSMShadowMap, c.addEventListener(&quot;resize&quot;, (() =&gt; {
                    t.setSize(c.innerWidth, c.innerHeight)
               })), u.body.appendChild(t.domElement), t
          }(),
          C = new e.AmbientLight(16777215, .1);
     ! function() {
          let e = [];
          for (let t = 0; t &lt; 32; t++) e.push(tokenData.hash.slice(2 + 2 * t, 4 + 2 * t));
          for (let t in O) {
               let l = &quot;&quot;,
                    n = O[t];
               for (let t = n[0]; t &lt;= n[1]; t++) l += e[t];
               let i = 2 ** (4 * l.length) - 1,
                    r = p(parseInt(l, 16), [0, i], [n[2], n[3]]);
               x[t] = r
          }
          0 != (b = x.R &lt; .7 ? 0 : x.R &lt; .8 ? 1 : x.R &lt; .9 ? 2 : 3) &amp;&amp; (x.L = Math.min(.35, x.L)), x.D += x.L, x.A += x.L
     }();
     var B = _(),
          Y = !1,
          U = {
               P: L(1, 0, 0),
               C: L(0, 1, 0),
               B: L(0, 0, 1)
          },
          V = g(255, 255, 255),
          k = [
               [g(158, 210, 255), g(31, 113, 141), g(150, 159, 178), g(93, 70, 50), g(255, 220, 127), g(255, 220, 127), g(85, 113, 28), g(34, 72, 18), g(236, 240, 241)],
               [g(50, 48, 49), g(31, 113, 141), g(50, 48, 49), g(8, 76, 97), g(0, 99, 93), g(255, 200, 87), g(0, 99, 93), g(175, 46, 41), g(240, 235, 216)],
               [g(85, 85, 151), g(159, 159, 237), g(50, 48, 49), g(242, 223, 215), g(11, 122, 117), g(107, 75, 62), g(11, 122, 117), g(212, 193, 236), g(240, 243, 245)],
               [g(9, 66, 70), g(132, 172, 206), g(125, 29, 63), g(107, 75, 62), g(216, 228, 206), g(216, 228, 206), g(13, 92, 99), g(179, 145, 174), g(238, 244, 237)]
          ],
          G = [
               [.8, .07],
               [.8, .25],
               [.7, .15],
               [.9, .2]
          ];
     N();
     var K = .03,
          W = .02,
          q = new z({
               color: 0 == b ? 11141120 : 1 == b ? k[b][1] : k[b][2]
          }),
          Z = new z({
               color: 16777215
          }),
          X = new z({
               color: 0
          }),
          j = new z({
               color: 16766720
          });
     class J {
          constructor(t, l, n, i, r, s) {
               let o = this;
               o.group = new e.Group, o.Y(), o.U(), o.V(), o.k(), o.G = o.K(), o.W(), o.q(), f(o.G), f(o.group), o.speed = 1.3, o.Z = l, o.X = n, o.j = r, o.J = i, o.$ = s, o.ee = .5, o.te = 0, o.le = new e.Quaternion, o.group.position.set(t.x, t.y, t.z), o.group.rotation.y = Math.PI, o.setScale(L(K, K, K)), o.ne = new e.Group, o.ne.add(o.group), o.camera = o.ie()
          }
          setScale(e) {
               this.group.scale.copy(e)
          }
          update(e) {
               let t = this;
               t.G.rotation.z += .4 * e / 10, o(4, .5), a(t.J);
               let l = .001,
                    n = s(t.J + t.te * l),
                    i = .005 * n;
               a(t.j), l = .01, n = s(t.j + t.te * l);
               let r = .01 * (n - .5);
               a(t.j), l = .001, n = s(t.$ + t.te * l);
               let c = .02 * (n - t.ee);
               t.te += 1, t.le.setFromAxisAngle(U.C, r * t.speed * e / 7), t.ne.quaternion.multiply(t.le), t.le.setFromAxisAngle(U.P, -i * t.speed * e / 7), t.ne.quaternion.multiply(t.le), t.le.setFromAxisAngle(U.B, 2 * -r * t.speed * e / 7), t.group.quaternion.multiply(t.le);
               let u = t.group.position,
                    h = u.length();
               if (t.ee = (h - t.Z) / (t.X - t.Z), h &lt; t.Z &amp;&amp; c &lt; 0 || h &gt; t.X &amp;&amp; c &gt; 0) return;
               let p = L().copy(u).multiplyScalar(c);
               u.add(p), t.camera.position.add(p)
          }
          ie() {
               let t = this,
                    l = new e.PerspectiveCamera(50, c.innerWidth / c.innerHeight, .01, 300),
                    n = L();
               t.group.getWorldPosition(n);
               let i = L();
               t.group.getWorldDirection(i);
               let r = l.position;
               r.set(n.x, n.y, n.z), r.multiplyScalar(1.03), r.add(i.normalize().multiplyScalar(.032)), l.quaternion.multiply(t.ne.quaternion);
               let s = new e.Quaternion;
               return s.setFromAxisAngle(U.P, -Math.PI / 4), l.quaternion.multiply(s), t.ne.add(l), l
          }
          Y() {
               let e = A(40, 40, 100);
               e.vertices[1].y -= 8, e.vertices[1].x -= 15, e.vertices[3].y += 20, e.vertices[3].x -= 15, e.vertices[4].y -= 8, e.vertices[4].x += 15, e.vertices[6].y += 20, e.vertices[6].x += 15;
               let t = D(e, q);
               this.group.add(t)
          }
          U() {
               let e = A(40, 40, 20);
               e.vertices[0].y -= 7, e.vertices[0].x -= 7, e.vertices[2].y += 7, e.vertices[2].x -= 7, e.vertices[5].y -= 7, e.vertices[5].x += 7, e.vertices[7].y += 7, e.vertices[7].x += 7;
               let t = D(e, Z);
               t.position.z = 60, this.group.add(t)
          }
          V() {
               let e = A(11, 30, 15);
               e.vertices[0].x -= 4, e.vertices[1].x -= 4, e.vertices[4].x += 4, e.vertices[5].x += 4;
               let t = D(e, Z),
                    l = t.position;
               l.z -= 52, l.y += 15.7, t.rotation.x += .2, this.group.add(t);
               let n = A(50, 3, 13),
                    i = D(n, Z),
                    r = i.position;
               r.z -= 52, r.y += 12, this.group.add(i)
          }
          k() {
               let e = A(170, 4, 30),
                    t = [{
                         re: -5,
                         se: 5
                    }, {
                         re: 25,
                         se: 5
                    }];
               for (let l of t) {
                    let t = D(e, q),
                         n = t.position;
                    n.y += l.re, n.z += l.se, this.group.add(t)
               }
               let l = A(2, 30, 3),
                    n = [{
                         px: 70,
                         re: 10,
                         se: 10,
                         oe: .2
                    }, {
                         px: 70,
                         re: 10,
                         se: 0,
                         oe: .2
                    }, {
                         px: -70,
                         re: 10,
                         se: 10,
                         oe: -.2
                    }, {
                         px: -70,
                         re: 10,
                         se: 0,
                         oe: -.2
                    }, {
                         px: -12,
                         re: 11,
                         se: 0,
                         oe: .5
                    }, {
                         px: -12,
                         re: 11,
                         se: 10,
                         oe: .5
                    }, {
                         px: 12,
                         re: 11,
                         se: 0,
                         oe: -.5
                    }, {
                         px: 12,
                         re: 11,
                         se: 10,
                         oe: -.5
                    }];
               for (let e of n) {
                    let t = D(l, Z),
                         n = t.position;
                    n.x += e.px, n.y += e.re, n.z += e.se, t.rotation.z += e.oe, this.group.add(t)
               }
          }
          K() {
               let e = A(10, 10, 20),
                    t = D(e, Z);
               return t.position.z = 65, this.group.add(t), t
          }
          W() {
               let e = A(6, 70, 1),
                    t = D(e, X);
               t.position.z = 8, this.G.add(t)
          }
          q() {
               var t, l;
               let n = A(2, 30, 3),
                    i = [{
                         px: -9,
                         re: -20,
                         se: 30,
                         rx: .5
                    }, {
                         px: -9,
                         re: -20,
                         se: 10,
                         rx: -.5
                    }, {
                         px: 9,
                         re: -20,
                         se: 30,
                         rx: .5
                    }, {
                         px: 9,
                         re: -20,
                         se: 10,
                         rx: -.5
                    }, {
                         px: 0,
                         re: -33,
                         se: 20,
                         rx: 0,
                         oe: Math.PI / 2,
                         ae: .9
                    }];
               for (let e of i) {
                    let i = D(n, X),
                         r = i.position;
                    r.x += e.px, r.y += e.re, r.z += e.se, i.rotation.x += e.rx, i.rotation.z = null !== (t = e.oe) &amp;&amp; void 0 !== t ? t : 0, i.scale.y = null !== (l = e.ae) &amp;&amp; void 0 !== l ? l : 1, this.group.add(i)
               }
               let r = new e.CylinderGeometry(7, 7, 3, 20),
                    s = [{
                         px: 11
                    }, {
                         px: -11
                    }];
               for (let e of s) {
                    let t = D(r, Z),
                         l = t.position;
                    l.x += e.px, l.y += -33, l.z += 20, t.rotation.z = Math.PI / 2, this.group.add(t)
               }
          }
     }
     class Q {
          constructor(t, l, n, i, r, s) {
               let o = this;
               o.group = new e.Group, o.Y(), o.U(), o.V(), o.ce = o.ue(), o.he = o.pe(), o.q(), o.W(), f(o.ce), f(o.he), f(o.group), o.speed = 1, o.de = .4, o.Z = l, o.X = n, o.j = r, o.J = i, o.$ = s, o.ee = .5, o.te = 0, o.le = new e.Quaternion, o._e = new e.Raycaster, o._e.p = n + 1, o.we = !1, o.fe = !1, o.Ee = !1, o.Se = Q.Ne, o.Te = null, o.group.position.set(t.x, t.y, t.z), o.group.rotation.y = Math.PI, o.setScale(L(K, K, K)), o.ne = new e.Group, o.ne.add(o.group), o.camera = o.ie(), o.ye = 0, o.Me = 0
          }
          setScale(e) {
               this.group.scale.copy(e)
          }
          update(e, t) {
               let l = this,
                    n = L();
               l.group.getWorldDirection(n);
               let i = L();
               l.group.getWorldPosition(i), l.ce.rotation.y += l.de * t / 10, l.he.rotation.x += l.de * t / 10, l.we ? l.Le(t) : l.Ee ? (l.Se -= t, l.Se &lt;= 0 &amp;&amp; l.me()) : l.fe ? l.Ae(t) : (l.De(t), l.Se -= t, l.Se &lt;= 0 &amp;&amp; l.ge(e))
          }
          ge(e) {
               let t = this,
                    l = L();
               t.group.getWorldPosition(l);
               let n = L().copy(l).multiplyScalar(-1).normalize();
               t._e.set(l, n);
               let i = t._e.intersectObject(e.ze);
               if (i.length &gt; 0) {
                    let e = i[0];
                    if (e.point.length() &lt;= 1.02 * te.Fe) t.Se = Q.Ne;
                    else {
                         let {
                              a: l,
                              b: n,
                              c: i
                         } = e.face, r = e.object.geometry.getAttribute(&quot;biom&quot;).array, s = [r[l], r[n], r[i]];
                         if (s.includes(3) || s.includes(4) || s.includes(5) || s.includes(6)) t.Se = Q.Ne;
                         else {
                              t.we = !0, t.de = .2, t.Te = e;
                              let l = L();
                              t.group.getWorldPosition(l), t.Me = l.length()
                         }
                    }
               } else t.Se = Q.Ne
          }
          Le(t) {
               let l = this,
                    n = L().copy(l.Te.point).length(),
                    i = L();
               if (l.group.getWorldPosition(i), i.length() - n &lt;= .5) l.we = !1, l.Ee = !0, l.de = .1, l.Se = Q.Ie;
               else {
                    let n = 5e-4 * t / 7,
                         i = l.group.position,
                         r = L().copy(i).multiplyScalar(n);
                    i.sub(r);
                    let s = new e.Quaternion,
                         o = -2e-4 * t / 7;
                    l.ye &gt; -Math.PI / 2 &amp;&amp; (l.ye += o, s.setFromAxisAngle(U.P, o), l.camera.quaternion.multiply(s))
               }
          }
          me() {
               let e = this;
               Math.random() &gt; .5 ? (e.Ee = !1, e.fe = !0, e.de = .4) : e.Se = Q.Ie
          }
          Ae(t) {
               let l = this,
                    n = L();
               if (l.group.getWorldPosition(n), l.Me - n.length() &lt;= 0) l.fe = !1, l.Se = Q.Ne;
               else {
                    let n = l.group.position,
                         i = 5e-4 * t / 7,
                         r = L().copy(n).multiplyScalar(i);
                    n.add(r);
                    let s = new e.Quaternion,
                         o = 2e-4 * t / 7;
                    l.ye &lt; 0 &amp;&amp; (l.ye += o, s.setFromAxisAngle(U.P, o), l.camera.quaternion.multiply(s))
               }
          }
          De(e) {
               let t = this;
               o(1, .6), a(t.J);
               let l = .001,
                    n = s(t.J + t.te * l),
                    i = .005 * n;
               a(t.j), l = .01, n = s(t.j + t.te * l);
               let r = .01 * (n - .3);
               a(t.j), l = .001, n = s(t.$ + t.te * l);
               let c = .02 * (n - t.ee);
               t.te += 1, t.le.setFromAxisAngle(U.C, r * e / 7), t.ne.quaternion.multiply(t.le), t.le.setFromAxisAngle(U.P, -i * t.speed * e / 7), t.ne.quaternion.multiply(t.le);
               let u = t.group.position,
                    h = u.length();
               if (t.ee = (h - t.Z) / (t.X - t.Z), h &lt; t.Z &amp;&amp; c &lt; 0 || h &gt; t.X &amp;&amp; c &gt; 0) return;
               let p = L().copy(u).multiplyScalar(c);
               u.add(p), t.camera.position.add(p)
          }
          ie() {
               let t = this,
                    l = new e.PerspectiveCamera(50, c.innerWidth / c.innerHeight, .01, 300),
                    n = L();
               t.group.getWorldPosition(n);
               let i = L();
               t.group.getWorldDirection(i);
               let r = l.position;
               r.set(n.x, n.y, n.z), r.multiplyScalar(1.2), r.add(i.normalize().multiplyScalar(-2.8)), l.quaternion.multiply(t.ne.quaternion);
               let s = new e.Quaternion;
               return s.setFromAxisAngle(U.P, -Math.PI / 3), l.quaternion.multiply(s), t.ne.add(l), l
          }
          Y() {
               let e = this,
                    t = A(50, 20, 100);
               t.vertices[0].z -= 15, t.vertices[5].z -= 15;
               let l = D(t, j);
               e.group.add(l);
               let n = A(50, 15, 100);
               n.vertices[3].z += 15, n.vertices[6].z += 15;
               let i = D(n, X);
               i.position.y -= 17.5, e.group.add(i);
               let r = A(50, 15, 10);
               r.vertices[0].y -= 3, r.vertices[2].y += 3, r.vertices[5].y -= 3, r.vertices[7].y += 3;
               let s = D(r, X),
                    o = s.position;
               o.y -= 17.5, o.z += 55, e.group.add(s);
               let a = A(50, 10, 85);
               a.vertices[3].z += 15, a.vertices[6].z += 15, a.vertices[2].z -= 15, a.vertices[7].z -= 15;
               let c = D(a, j),
                    u = c.position;
               u.y -= 30, u.z += 7.5, e.group.add(c)
          }
          U() {
               let e = A(20, 10, 40);
               e.vertices[0].z -= 7, e.vertices[5].z -= 7, e.vertices[2].x += 3, e.vertices[3].z -= 99, e.vertices[3].x -= 4, e.vertices[6].z -= 99, e.vertices[6].x += 4;
               let t = D(e, X),
                    l = t.position;
               l.y += 15, l.z += 10, this.group.add(t)
          }
          V() {
               let e = this,
                    t = A(50, 20, 60);
               t.vertices[1].x -= 18, t.vertices[3].x -= 18, t.vertices[3].y += 13, t.vertices[4].x += 18, t.vertices[6].x += 18, t.vertices[6].y += 13;
               let l = D(t, j);
               l.position.z -= 80, e.group.add(l);
               let n = A(70, 3, 15),
                    i = D(n, X),
                    r = i.position;
               r.y += 5, r.z -= 80, e.group.add(i);
               let s = A(2, 20, 15),
                    o = [{
                         px: -35
                    }, {
                         px: 35
                    }];
               for (let t of o) {
                    let l = D(s, X),
                         n = l.position;
                    n.x += t.px, n.y += 5, n.z += -80, e.group.add(l)
               }
          }
          ue() {
               let e = A(4, 30, 4),
                    t = D(e, X),
                    l = t.position;
               return l.y += 15, l.z += 10, this.group.add(t), t
          }
          pe() {
               let e = A(10, 4, 4),
                    t = D(e, X),
                    l = t.position;
               return l.x += 10, l.y += 6, l.z -= 105, this.group.add(t), t
          }
          W() {
               let e = this,
                    t = A(160, 2, 12),
                    l = D(t, X);
               l.position.y += 12, e.ce.add(l);
               let n = D(t, X);
               n.position.y += 12, n.rotation.y += Math.PI / 2, e.ce.add(n);
               let i = A(2, 20, 3),
                    r = D(i, X);
               r.position.x += 3, e.he.add(r)
          }
          q() {
               let e = A(2, 3, 60),
                    t = [{
                         px: 30
                    }, {
                         px: -30
                    }];
               for (let l of t) {
                    let t = D(e, X),
                         n = t.position;
                    n.x += l.px, n.y -= 50, n.z += 10, this.group.add(t)
               }
               let l = A(2, 20, 3),
                    n = [{
                         px: 25,
                         se: 25,
                         oe: Math.PI / 7
                    }, {
                         px: 25,
                         se: -5,
                         oe: Math.PI / 7
                    }, {
                         px: -25,
                         se: 25,
                         oe: -Math.PI / 7
                    }, {
                         px: -25,
                         se: -5,
                         oe: -Math.PI / 7
                    }];
               for (let e of n) {
                    let t = D(l, X),
                         n = t.position;
                    n.x += e.px, n.y += -40, n.z += e.se, t.rotation.z += e.oe, this.group.add(t)
               }
          }
     }
     Q.Ne = 2e4, Q.Ie = 1e4;
     class $ {
          constructor(t, l, n, i) {
               let r = this;
               r.xe = new e.Group, r.Oe = new e.Group;
               let s = V;
               for (let o = 0; o &lt; n; o++) {
                    let n = T(i + (o + 1)),
                         a = T(n),
                         c = T(a),
                         u = T(c),
                         h = T(u),
                         p = n * l + t,
                         d = new e.DodecahedronBufferGeometry(p),
                         _ = L(12 * (a - .5), 12 * (c - .5), 4 * (u - 1)),
                         w = 1 - _.length() / 6,
                         f = new e.MeshBasicMaterial({
                              color: s,
                              opacity: Math.max(w, .1),
                              transparent: !0
                         }),
                         E = D(d, f);
                    r.Oe.add(E), E.position.set(_.x, _.y, _.z);
                    let S = .7 + 1 * h;
                    E.scale.set(S, S, S), E.receiveShadow = !0
               }
               r.xe.add(r.Oe);
               let o = T(i),
                    a = T(o),
                    c = T(a),
                    u = T(c);
               r.be = {
                    axis: L(o, a, c).normalize(),
                    speed: 1e-5 + 3e-5 * u,
                    quaternion: new e.Quaternion,
                    ne: r.xe
               }
          }
          update(e) {
               let {
                    axis: t,
                    speed: l,
                    quaternion: n,
                    ne: i
               } = this.be;
               n.setFromAxisAngle(t, e * l), i.quaternion.multiply(n)
          }
     }
     class ee {
          constructor(t) {
               let l = this;
               l.ve = new e.Group, l.ve.position.set(0, 0, 0), l.ve.receiveShadow = !0, l.Re = l.He(t - 2, 15), l.Pe = null, l.Pe = l.Ce(t + 2, 0), l.Be = null, w() &amp;&amp; (l.Be = l.Ce(t + 2, 1))
          }
          Ye() {
               H.add(this.ve)
          }
          rotate(e) {
               this.ve.applyQuaternion(e)
          }
          update(e, t) {
               let l = this;
               for (let e of l.Re) e.update(t);
               null != l.Pe &amp;&amp; l.Pe.update(t), null != l.Be &amp;&amp; l.Be.update(e, t)
          }
          He(e, t) {
               let l = [];
               for (let n = 0; n &lt; Math.ceil(x.H); n++) {
                    let i = T(x.I + (n + 1)),
                         r = T(i),
                         s = T(r),
                         o = T(s),
                         a = new $(.5, 1.5, 40, i),
                         c = 2 * Math.PI * r,
                         u = 2 * Math.PI * s,
                         h = e + o * t,
                         p = a.Oe.position;
                    p.x = h * Math.sin(c) * Math.cos(u), p.z = h * Math.cos(c) * Math.cos(u), p.y = h * Math.sin(u), a.Oe.lookAt(0, 0, 0), this.ve.add(a.xe), l.push(a)
               }
               return l
          }
          Ce(e, t) {
               let l = T(x.I * x.I + t),
                    n = T(l),
                    i = T(n),
                    r = L(0, e, 0),
                    s = l,
                    o = n,
                    a = i,
                    c = 0 == t ? new J(r, e, e + 20, o, s, a) : new Q(r, e, e + 20, o, s, a);
               return this.ve.add(c.ne), c
          }
     }
     class te {
          constructor() {
               let e = this;
               e.X = 0;
               let t = [{
                    id: 0,
                    Ue: !0,
                    Ve: !0,
                    ke: {
                         Ge: x.M,
                         Ke: .05,
                         We: .5,
                         qe: 3,
                         minValue: x.L,
                         Ze: L(0, 0, 0)
                    },
                    Xe: [{
                         color: k[b][5],
                         je: 1.03
                    }, {
                         color: k[b][6],
                         je: 10
                    }]
               }, {
                    id: 1,
                    Ue: !1,
                    Ve: !1,
                    Je: [0],
                    ke: {
                         Ge: 2,
                         Ke: x.m,
                         We: .5,
                         qe: 2,
                         minValue: x.A,
                         Ze: L(0, 0, 0)
                    },
                    Xe: [{
                         color: k[b][4],
                         je: 10
                    }]
               }, {
                    id: 2,
                    Ue: !1,
                    Ve: !1,
                    Je: [0],
                    ke: {
                         Ge: 1,
                         Ke: 1,
                         We: .35,
                         qe: 2,
                         minValue: .2 + x.L,
                         Ze: L(10, 10, 10)
                    },
                    Xe: [{
                         color: k[b][6],
                         je: 10
                    }]
               }, {
                    id: 3,
                    Ue: !1,
                    Ve: !0,
                    ke: {
                         Ge: 7.2,
                         Ke: .037,
                         We: .49,
                         qe: x.v,
                         minValue: x.D,
                         Ze: L(0, 0, 0)
                    },
                    Xe: [{
                         color: k[b][3],
                         je: x.O
                    }, {
                         color: k[b][2],
                         je: 10
                    }, {
                         color: k[b][8],
                         je: 200
                    }]
               }, {
                    id: 4,
                    Ue: !1,
                    Ve: !0,
                    Je: [3],
                    ke: {
                         Ge: .8,
                         Ke: 1,
                         We: .5,
                         qe: x.v,
                         minValue: x.D,
                         Ze: L(15, 15, 15)
                    },
                    Xe: [{
                         color: k[b][3],
                         je: x.O
                    }, {
                         color: k[b][2],
                         je: 10
                    }, {
                         color: k[b][8],
                         je: 200
                    }]
               }, {
                    id: 5,
                    Ue: !1,
                    Ve: !1,
                    Je: [0, 3, 4],
                    Qe: 1.1 * te.Fe,
                    ke: {
                         Ge: 4,
                         Ke: .06,
                         We: .46,
                         qe: Math.round(x.F),
                         minValue: .41,
                         Ze: L(0, 0, 0)
                    },
                    Xe: [{
                         color: k[b][6],
                         je: 10
                    }]
               }, {
                    id: 6,
                    Ue: !1,
                    Ve: !0,
                    Je: [5],
                    ke: {
                         Ge: 1,
                         Ke: 5,
                         We: .51,
                         qe: 4,
                         minValue: .3,
                         Ze: L(0, 0, 0)
                    },
                    Xe: [{
                         color: k[b][7],
                         je: 10
                    }]
               }, {
                    id: 7,
                    Ue: !1,
                    Ve: !0,
                    Je: [2],
                    ke: {
                         Ge: .7,
                         Ke: 3,
                         We: .5,
                         qe: 2,
                         minValue: .4,
                         Ze: L(0, 0, 0)
                    },
                    Xe: [{
                         color: k[b][6],
                         je: 10
                    }]
               }];
               e.$e = e.et(t, R), e.$e.castShadow = !0, w() ? (e.ze = e.et(t, 30), e.ze.visible = !1) : e.ze = null
          }
          et(t, l) {
               let n = new e.IcosahedronBufferGeometry(te.Fe, l),
                    i = new e.MeshToonMaterial({
                         flatShading: !0,
                         vertexColors: !0
                    }),
                    r = n.getAttribute(&quot;position&quot;).array.length / 3,
                    s = new Int32Array(r).fill(-1);
               n.setAttribute(&quot;biom&quot;, new e.BufferAttribute(s, 1));
               let o = new Float32Array(3 * r).fill(0);
               n.setAttribute(&quot;color&quot;, new e.BufferAttribute(o, 3)), this.tt(n, te.Fe, t), this.lt(n, te.Fe, t);
               let a = D(n, i);
               return a.receiveShadow = !0, a
          }
          tt(t, l, n) {
               let i = this,
                    r = t.getAttribute(&quot;position&quot;),
                    s = new Float32Array(r.array.length);
               s.set(r.array);
               let o = r.array.length / 3,
                    c = t.getAttribute(&quot;biom&quot;),
                    u = new Int32Array(c.array.length);
               u.set(c.array);
               let h = 0,
                    p = [],
                    _ = T(x.T) * v;
               a(_);
               for (let e = 0; e &lt; o; e++) {
                    let t = r.array[3 * e],
                         o = r.array[3 * e + 1],
                         a = r.array[3 * e + 2],
                         c = L(t, o, a);
                    for (let t of n)
                         if (t.Ue) u[e] = t.id, h = i.nt(c, t.ke, d() ? 0 : _), p[e] = h, c.normalize().multiplyScalar(l + h), s[3 * e] = c.x, s[3 * e + 1] = c.y, s[3 * e + 2] = c.z;
                         else {
                              if (null != t.Qe &amp;&amp; c.length() &gt; t.Qe) continue;
                              let n = u[e];
                              if (null != t.Je &amp;&amp; !t.Je.includes(n)) continue;
                              let r = p[e],
                                   o = h + i.nt(c, t.ke, d() ? 0 : _) * r;
                              o &gt; h &amp;&amp; (u[e] = t.id, t.Ve &amp;&amp; (h = o, c.normalize().multiplyScalar(l + h), s[3 * e] = c.x, s[3 * e + 1] = c.y, s[3 * e + 2] = c.z))
                         } let w = c.length();
                    w &gt; i.X &amp;&amp; (i.X = w)
               }
               t.setAttribute(&quot;position&quot;, new e.BufferAttribute(s, 3)), t.setAttribute(&quot;biom&quot;, new e.BufferAttribute(u, 1))
          }
          lt(t, l, n) {
               let i = new Float32Array(t.getAttribute(&quot;color&quot;).array.length),
                    r = t.getAttribute(&quot;position&quot;),
                    s = t.getAttribute(&quot;biom&quot;),
                    o = r.array.length / 3;
               for (let e = 0; e &lt; o; e++) {
                    let t = n.find((t =&gt; t.id == s.array[e]));
                    if (null == t) {
                         i[3 * e] = k[b][3].r, i[3 * e + 1] = k[b][3].g, i[3 * e + 2] = k[b][3].b;
                         continue
                    }
                    let o, a = r.array[3 * e],
                         c = r.array[3 * e + 1],
                         u = r.array[3 * e + 2],
                         h = L(a, c, u).length();
                    if ((3 == t.id || 4 == t.id) &amp;&amp; h &gt; 1.2 * te.Fe &amp;&amp; h &gt;= .88 * this.X) o = t.Xe[t.Xe.length - 1].color;
                    else
                         for (let e of t.Xe)
                              if (h &lt; l * e.je) {
                                   o = e.color;
                                   break
                              } i[3 * e] = o.r, i[3 * e + 1] = o.g, i[3 * e + 2] = o.b
               }
               t.setAttribute(&quot;color&quot;, new e.BufferAttribute(i, 3)), w() || t.deleteAttribute(&quot;biom&quot;)
          }
          nt(e, t, l) {
               o(t.qe, t.We);
               let n = l + e.x * t.Ke + t.Ze.x,
                    i = l + e.y * t.Ke + t.Ze.y,
                    r = l + e.z * t.Ke + t.Ze.z,
                    a = s(n, i, r);
               return Math.max(0, a - t.minValue) * t.Ge
          }
          Ye() {
               let e = this;
               H.add(e.$e), null != e.ze &amp;&amp; H.add(e.ze)
          }
          rotate(e) {
               var t;
               this.$e.applyQuaternion(e), null === (t = this.ze) || void 0 === t || t.applyQuaternion(e)
          }
     }
     te.Fe = 39.5;
     class le {
          constructor() {
               let t = this,
                    l = new e.IcosahedronGeometry(le.it, 35),
                    n = l.vertices.length;
               t.rt = [];
               for (let e = 0; e &lt; n; e++) {
                    let n = T(x.N + e + 1),
                         i = T(n),
                         r = T(i),
                         s = T(r),
                         o = l.vertices[e],
                         a = i,
                         c = .3 * r,
                         u = .03 * s;
                    t.rt.push({
                         y: o.y,
                         x: o.x,
                         z: o.z,
                         st: a,
                         ot: c,
                         speed: u
                    })
               }
               let i = new e.MeshToonMaterial({
                    flatShading: !0,
                    color: k[b][1]
               });
               t.at = D(l, i), t.at.receiveShadow = !0, t.at.castShadow = !0
          }
          Ye() {
               H.add(this.at)
          }
          update(e) {
               let t = this.at.geometry,
                    l = t.vertices,
                    n = l.length;
               for (let t = 0; t &lt; n; t++) {
                    let n = T(x.N + t + 1),
                         i = T(n),
                         r = T(i),
                         s = l[t],
                         o = this.rt[t];
                    s.x = o.x + Math.cos(o.st + .001 * n * e) * o.ot, s.y = o.y + Math.sin(o.st + .001 * i * e) * o.ot, s.z = o.z + Math.sin(o.st + .001 * r * e) * o.ot, o.st += o.speed
               }
               t.verticesNeedUpdate = !0
          }
          rotate(e) {
               this.at.applyQuaternion(e)
          }
     }
     le.it = 40;
     class ne {
          constructor() {
               let t = this;
               t.le = new e.Quaternion;
               let l = T(x.S),
                    n = T(l);
               t.ut = m(.002 * l, .002 * n), t.ht = new te, t.dt = new le, t._t = new ee(t.ht.X)
          }
          Ye() {
               let e = this;
               e._t.Ye(), e.ht.Ye(), e.dt.Ye()
          }
          update(e, t) {
               let l = this;
               if (e || Y) {
                    let e = l.ut.clone().multiplyScalar(-.02 * t / 6);
                    l.ut.add(e)
               }
               l.wt(t), Y || (l.dt.update(t), l._t.update(l.ht, t))
          }
          ft(e, t) {
               this.ut.set(e, t).divideScalar(Y ? 3e3 : 1300)
          }
          wt(e) {
               let t = this,
                    l = [
                         [U.P, t.ut.x],
                         [U.C, t.ut.y]
                    ];
               for (let n of l) t.le.setFromAxisAngle(n[0], n[1] * e / 6), t._t.rotate(t.le), t.ht.rotate(t.le), t.dt.rotate(t.le)
          }
     }
     class ie {
          constructor() {
               let t = this;
               t.Et = new e.PerspectiveCamera(75, c.innerWidth / c.innerHeight, .1, 400);
               let l = t.Et.position;
               l.y = 0, l.x = 0, l.z = 180, t.Et.lookAt(0, 0, 0), t.St = t.Et, t.Nt = !1, t.Tt = !1, t.yt = new Map, t.Mt(), t.Lt = new re, t.At = new ne, t.Dt = !1, t.delta = 0
          }
          static gt() {
               return null == ie.zt ? (ie.zt = new ie, ie.zt) : ie.zt
          }
          static Ft() {
               null != ie.zt &amp;&amp; (ie.zt.It(), ie.zt = void 0)
          }
          Ye() {
               this.At.Ye()
          }
          update(e) {
               let t = this;
               t.delta = e, t.At.update(t.Dt, e)
          }
          render() {
               P.render(H, this.St)
          }
          Mt() {
               let e = this;
               e.xt(&quot;resize&quot;, (() =&gt; {
                    e.Et.aspect = c.innerWidth / c.innerHeight, e.Et.updateProjectionMatrix();
                    let t = e.At._t.Pe;
                    null != t &amp;&amp; (t.camera.aspect = c.innerWidth / c.innerHeight, t.camera.updateProjectionMatrix());
                    let l = e.At._t.Be;
                    null != l &amp;&amp; (l.camera.aspect = c.innerWidth / c.innerHeight, l.camera.updateProjectionMatrix())
               })), e.xt(&quot;keydown&quot;, (t =&gt; {
                    if (&quot;p&quot; == t.key) c.dispatchEvent(new F(&quot;p&quot;));
                    else if (&quot;h&quot; == t.key) c.dispatchEvent(new F(&quot;h&quot;));
                    else if (&quot;n&quot; == t.key &amp;&amp; _()) B = !B, N(), H.remove(C), H.remove(y), H.remove(M), S();
                    else if (&quot; &quot; == t.key) Y = !Y;
                    else if (!isNaN(t.key) &amp;&amp; &quot; &quot; != t.key) {
                         ! function(e) {
                              Y = !1, R = e, H.clear(), S(), ie.Ft(), ie.gt().Ye()
                         }(&quot;0&quot; === t.key ? 300 : 30 * t.key)
                    }
                    e.St.updateProjectionMatrix()
               })), e.xt(&quot;wheel&quot;, (e =&gt; {
                    c.dispatchEvent(new I(&quot;zw&quot;, {
                         detail: e.deltaY &gt; 0 ? 70 : -70
                    }))
               })), e.xt(&quot;contextmenu&quot;, (e =&gt; e.preventDefault())), e.xt(&quot;pointercancel&quot;, (t =&gt; {
                    e.Lt.Ot(t)
               })), e.xt(&quot;pointerleave&quot;, (t =&gt; {
                    e.Lt.Ot(t)
               })), e.xt(&quot;pointerout&quot;, (t =&gt; {
                    e.Lt.Ot(t)
               })), e.xt(&quot;pointerup&quot;, (t =&gt; {
                    e.Lt.Ot(t)
               })), e.xt(&quot;pointerdown&quot;, (t =&gt; {
                    e.Lt.Ot(t)
               })), e.xt(&quot;pointermove&quot;, (t =&gt; {
                    e.Lt.Ot(t)
               })), e.xt(&quot;a&quot;, (t =&gt; {
                    e.Nt ? w() ? c.dispatchEvent(new F(&quot;h&quot;)) : c.dispatchEvent(new F(&quot;p&quot;)) : e.Tt ? c.dispatchEvent(new F(&quot;h&quot;)) : c.dispatchEvent(new F(&quot;p&quot;))
               })), e.xt(&quot;s&quot;, (t =&gt; {
                    e.Dt = t.detail
               })), e.xt(&quot;r&quot;, (t =&gt; {
                    let l = e.delta / 8;
                    e.At.ft(t.detail.dy * l, t.detail.dx * l)
               })), e.xt(&quot;zw&quot;, (e =&gt; {
                    let t = e.detail;
                    c.dispatchEvent(new I(&quot;z&quot;, {
                         detail: t
                    }))
               })), e.xt(&quot;z&quot;, (t =&gt; {
                    let l = t.detail;
                    l &gt; 0 ? e.St.fov &lt; 115 &amp;&amp; (e.St.fov += l / 50) : e.St.fov &gt; 20 &amp;&amp; (e.St.fov += l / 50), e.St.updateProjectionMatrix()
               })), e.xt(&quot;p&quot;, (t =&gt; {
                    let l = e.At._t.Pe;
                    if (null != l)
                         if (e.Nt) {
                              e.St = e.Et, e.Nt = !1, l.setScale(L(K, K, K));
                              let t = e.At._t.Be;
                              null != t &amp;&amp; t.setScale(L(K, K, K))
                         } else {
                              l.setScale(L(.01, .01, .01)), e.St = l.camera, e.Nt = !0;
                              let t = e.At._t.Be;
                              null != t &amp;&amp; (t.setScale(L(W, W, W)), e.Tt = !1)
                         }
               })), e.xt(&quot;h&quot;, (t =&gt; {
                    let l = e.At._t.Be;
                    if (null != l)
                         if (e.Tt) {
                              e.St = e.Et, e.Tt = !1, l.setScale(L(K, K, K));
                              let t = e.At._t.Pe;
                              null != t &amp;&amp; t.setScale(L(K, K, K))
                         } else {
                              l.setScale(L(.01, .01, .01)), e.St = l.camera, e.Tt = !0;
                              let t = e.At._t.Pe;
                              null != t &amp;&amp; (t.setScale(L(W, W, W)), e.Nt = !1)
                         }
               }))
          }
          xt(e, t) {
               this.yt.set(e, t), c.addEventListener(e, t)
          }
          It() {
               for (let [e, t] of this.yt) c.removeEventListener(e, t)
          }
     }
     class re {
          constructor() {
               let e = this;
               e.bt = [], e.vt = [], e.Rt = new Map
          }
          Ot(e) {
               let t = this;
               switch (e.preventDefault(), e.type) {
                    case &quot;pointerdown&quot;:
                         0 == t.bt.length ? (t.bt.push(e), t.Rt.set(e.pointerId, [e]), c.dispatchEvent(new I(&quot;s&quot;, {
                              detail: !0
                         }))) : 1 == t.bt.length ? (t.bt.push(e), t.Rt.set(e.pointerId, [e]), c.dispatchEvent(new I(&quot;s&quot;, {
                              detail: !1
                         }))) : 2 == t.bt.length ? (t.bt.push(e), c.dispatchEvent(new I(&quot;s&quot;, {
                              detail: !1
                         }))) : (t.bt = [], t.vt = [], t.Rt.clear());
                         break;
                    case &quot;pointerout&quot;:
                    case &quot;pointercancel&quot;:
                    case &quot;pointerleave&quot;:
                    case &quot;pointerup&quot;:
                         if (1 == t.bt.length) {
                              t.bt.pop();
                              t.Rt.clear(), c.dispatchEvent(new I(&quot;s&quot;, {
                                   detail: !1
                              }))
                         } else 2 == t.bt.length ? 0 == t.vt.length ? t.vt.push(e) : 1 == t.vt.length &amp;&amp; (t.bt = [], t.vt = [], t.Rt.clear()) : 3 == t.bt.length &amp;&amp; (t.vt.length &lt; 2 ? t.vt.push(e) : 2 == t.vt.length &amp;&amp; (t.bt = [], t.vt = [], t.Rt.clear(), c.dispatchEvent(new I(&quot;a&quot;))));
                         break;
                    case &quot;pointermove&quot;:
                         if (1 == t.bt.length) {
                              let l = t.Rt.get(e.pointerId);
                              if (null != l &amp;&amp; 2 == l.length) {
                                   let n = l[0],
                                        i = e.clientX - n.clientX,
                                        r = e.clientY - n.clientY;
                                   c.dispatchEvent(new I(&quot;r&quot;, {
                                        detail: {
                                             dx: i,
                                             dy: r
                                        }
                                   })), t.Rt.clear()
                              } else null == l ? t.Rt.set(e.pointerId, [e]) : l.push(e)
                         } else if (2 == t.bt.length) {
                              let l = t.Rt.get(t.bt[0].pointerId),
                                   n = t.Rt.get(t.bt[1].pointerId);
                              if (l.length + n.length &gt;= 2) {
                                   let i = l[l.length - 1],
                                        r = n[n.length - 1],
                                        s = m(i.clientX - r.clientX, i.clientY - r.clientY).length(),
                                        o = e.pointerId == t.bt[0].pointerId ? r : i,
                                        a = m(e.clientX - o.clientX, e.clientY - o.clientY).length() - s;
                                   c.dispatchEvent(new I(&quot;zw&quot;, {
                                        detail: 8 * -a
                                   }))
                              }
                              let i = t.Rt.get(e.pointerId);
                              null == i ? t.Rt.set(e.pointerId, [e]) : i.push(e)
                         }
               }
          }
          Ht() {
               let e = this;
               e.bt = [], e.vt = [], e.Rt.clear()
          }
     }! function() {
          S(), ie.gt().Ye();
          let e = 0,
               t = u.getElementsByTagName(&quot;canvas&quot;)[0];
          t.style.touchAction = &quot;none&quot;, t.style.userSelect = &quot;none&quot;, t.style.cursor = &quot;pointer&quot;, t.style.overflow = &quot;hidden&quot;, t.style.width = &quot;100%&quot;, t.style.height = &quot;100%&quot;, requestAnimationFrame((function t(l) {
               let n = l - e;
               e = l, ie.gt().update(n), ie.gt().render(), requestAnimationFrame(t)
          }))
     }()
})();</pre></body></html>