<html><body><h1>Name: Spaghettification</h1><h3>Artist: Owen Moore</h3><h3>Description: Representing the ebb and flow of energy in a universe heading towards inevitable entropy.</h3><h3>https://twitter.com/owenmoore_art</h3><hr/><p>Script JSON: {&quot;type&quot;:&quot;p5js&quot;,&quot;aspectRatio&quot;:&quot;1&quot;,&quot;animationLengthInSeconds&quot;:&quot;1&quot;}</p><p>Script Type: p5js</p><p>Version: </p><p>Script Ratio: 1</p><p>Instructions: </p><p>Hashes Generated per Token: true</p><p>Dynamic Asset? true</p><hr/><p>Artist Ethereum Address: 0xf429690d7f1b2ef1dd77c150831f4367e366aeac</p><p>Additional Payee: 0x0000000000000000000000000000000000000000</p><p>Additional Payee Percentage: 0</p><p>Price: 0.05</p><p>Currency: ETH</p><p>Currency Address: N/A</p><p>Invocations: 1024</p><p>Maximum Invocations: 1024</p><p>License: NFT License 2.0</p><p>Token Ids: 99000000,99000001,99000002,99000003,99000004,99000005,99000006,99000007,99000008,99000009,99000010,99000011,99000012,99000013,99000014,99000015,99000016,99000017,99000018,99000019,99000020,99000021,99000022,99000023,99000024,99000025,99000026,99000027,99000028,99000029,99000030,99000031,99000032,99000033,99000034,99000035,99000036,99000037,99000038,99000039,99000040,99000041,99000042,99000043,99000044,99000045,99000046,99000047,99000048,99000049,99000050,99000051,99000052,99000053,99000054,99000055,99000056,99000057,99000058,99000059,99000060,99000061,99000062,99000063,99000064,99000065,99000066,99000067,99000068,99000069,99000070,99000071,99000072,99000073,99000074,99000075,99000076,99000077,99000078,99000079,99000080,99000081,99000082,99000083,99000084,99000085,99000086,99000087,99000088,99000089,99000090,99000091,99000092,99000093,99000094,99000095,99000096,99000097,99000098,99000099</p><p>Active? true</p><p>Paused? false</p><hr/><p><strong>Script:</strong></p><pre>function setup() {
     switch (createCanvas(dim, dim), colorMode(HSB, 360, 100, 100, 100), angleMode(DEGREES), ellipseMode(CENTER), rectMode(CENTER), mkP(arg.h, arg.s, arg.v, 1), arg.c) {
          case 0:
          default:
               mkP(mod(arg.h + 180 + 5, 360), arg.s + 5, arg.v - 5, 1), mkP(mod(arg.h + 180 - 5, 360), arg.s - 5, arg.v + 5, 1);
               break;
          case 1:
               mkP(mod(arg.h - 30, 360), arg.s, arg.v, 1), mkP(mod(arg.h + 30, 360), arg.s, arg.v, 1);
               break;
          case 2:
               mkP(mod(arg.h - 120, 360), arg.s, arg.v, 1), mkP(mod(arg.h + 120, 360), arg.s, arg.v, 1)
     }
     for (pts = [], rt = int(360 / arg.n), t = 0; t &lt; arg.n; t++) T[t] = new Tube(t * rt + R.bt(-18, 18) + parseInt(mpp(rns[7], 0, 30))), pts.push([T[t].xT, T[t].yT]);
     E = new EventHorizon(pts), draw()
}

function draw() {
     for (noStroke(), E.tck(), noFill(), stroke(sCol), strokeWeight(.1 * width), rect(.5 * width, .5 * height, width, height, .1 * width), noStroke(), t = 0; t &lt; T.length; t++) T[t].tck()
}

function mkP(t, s, h, r) {
     for (i = -cP; i &lt; cP; i++) P.push([t + i * int(cP / 16), s - i * arg.d * int(cP / 8), h + i * arg.d * int(cP / 8) + h / 2, r])
}

function mpd(t, s, h, i, r) {
     return (t - s) / (h - s) * (r - i) + i
}

function mpp(t, s, h) {
     return mpd(t, 0, 255, s, h)
}

function mod(t, s) {
     return (t % s + s) % s
}
for (seed = parseInt(tokenData.hash.slice(0, 16), 16), hs = [], j = 0; j &lt; 32; j++) hs.push(tokenData.hash.slice(2 + 2 * j, 4 + 2 * j));
rns = hs.map(t =&gt; parseInt(t, 16));
class Random {
     constructor(t) {
          this.seed = t
     }
     dec() {
          return this.seed ^= this.seed &lt;&lt; 13, this.seed ^= this.seed &gt;&gt; 17, this.seed ^= this.seed &lt;&lt; 5, (this.seed &lt; 0 ? 1 + ~this.seed : this.seed) % 1e3 / 1e3
     }
     bt(t, s) {
          return t + (s - t) * this.dec()
     }
     ch(t) {
          return t[Math.floor(this.bt(0, .99 * t.length))]
     }
}
R = new Random(seed), arg = {
     h: parseInt(mpp(rns[1], 0, 360)),
     s: parseInt(mpp(rns[2], 80, 60)),
     v: parseInt(mpp(rns[2], 35, 45)),
     x: mpp(rns[3], -.125, .125),
     y: mpp(rns[4], -.125, .125),
     d: R.ch([-1, 1]),
     r: parseInt(mpp(rns[5], 30, 60)),
     i: mpp(rns[6], .1, .3),
     c: R.ch([0, 1, 2]),
     n: R.ch([3, 4, 5]),
     bSc: mpp(rns[8], .15, .3),
     tSc: mpp(rns[10], 4, 12),
     cyb: mpp(rns[16], 0, 100),
     blw: mpp(rns[17], 0, 100)
}, arg.cyb &lt;= 6 ? (arg.s = 130, arg.v = 30) : arg.blw &lt;= 4 &amp;&amp; (arg.s = 0, arg.v = 50), P = [], T = [], E = null, cP = 30, cS = 256, dim = Math.min(window.innerWidth, window.innerHeight), sCol = [arg.h, arg.s - 20, arg.v - 20, 100];
class EventHorizon {
     constructor(t) {
          this.vrt = [];
          let s = 0,
               h = 0;
          for (let i = 0; i &lt; t.length; i++) {
               let r = t[i][0] + width * -arg.x / 3,
                    e = t[i][1] + height * -arg.y / 3;
               this.vrt.push([r, e]), s += r, h += e
          }
          this.cX = Math.round(s / this.vrt.length), this.cY = Math.round(h / this.vrt.length), this.oX = width / 4 * R.bt(-.1, .1), this.oY = height / 4 * R.bt(-.1, .1);
          for (let t = 0; t &lt; this.vrt.length; t++) this.vrt[t][0] -= this.cX, this.vrt[t][1] -= this.cY;
          this.phV = 0, this.phS = 0, this.osc = sin(Math.PI / this.fq * 2)
     }
     tck() {
          this.phV += arg.i, this.phV &gt; this.osc &amp;&amp; (this.phV -= this.osc), this.phS -= arg.i, this.phS &lt; -this.osc &amp;&amp; (this.phS += this.osc);
          let t = 24;
          for (let s = t; s &gt; 0; s--) {
               fill(arg.h + mpd(s, t, 0, -60, 180), arg.s + mpd(s, t, 0, -40, 40), arg.v + mpd(s, t, 0, 30, -60), 100);
               let h = 1.65 * width * mpd(-s / t * (s / t) * (s / t) * (s / t) + 1, 0, 1, 1, arg.bSc),
                    i = mpd(sin(Math.PI / 1 * 2 * (this.phV + 4 * s - 1)), -1, 1, .9, 1.1);
               ellipse(this.cX + this.oX, this.cY + this.oY, h * i, h * i)
          }
          for (let s = t = 8; s &gt;= 0; s--) {
               s == t ? fill(arg.h + 30, arg.s - 20, arg.v + 50, 100) : fill(mpd(s, 0, t, arg.h - 30, arg.h + 30), mpd(s, 0, t, arg.s + 40, arg.s - 40), mpd(s, 0, t, -20, arg.v + 20), 100);
               let h = mpd(sin(Math.PI / 1 * 2 * (this.phS + 4 * s - 1)), -1, 1, 1.1, .9);
               beginShape();
               for (let i = 0; i &lt; this.vrt.length; i++) s == t ? vertex(this.cX + 1.025 * this.vrt[i][0] * h, this.cY + 1.025 * this.vrt[i][1] * h) : vertex(this.cX + this.vrt[i][0] * mpd(s, 0, t, .1, h), this.cY + this.vrt[i][1] * mpd(s, 0, t, .1, h));
               endShape()
          }
     }
}
class Tube {
     constructor(t) {
          this.wSc = arg.tSc + R.bt(-arg.tSc / 4, arg.tSc / 2), this.wFq = (mpp(rns[11], .6, 1) + R.bt(-.05, .05)) * arg.d, this.wSp = (mpp(rns[12], .4, .6) + R.bt(-.05, .05)) * arg.d, this.wPh = sin(Math.PI / this.wFq * 2) * R.bt(.2, .8) + R.bt(-.5, .5), this.wRt = mpd(arg.i, .05, .25, .4, 1);
          let s = Math.round(R.bt(0, 1)) * cP * 2 + 2 * cP,
               h = 1 === arg.d ? arg.r : -arg.r,
               i = R.bt(0, R.bt(-.1, .1));
          this.segments = new Array(cS);
          for (let r = 0; r &lt; cS; r++) {
               let e = r / cS * (r / cS),
                    n = -e * e + 1,
                    a = Math.round(cP / 5),
                    c = mpd(r, 0, cS, 0, 2 * cP - a - 1),
                    g = Math.round(R.bt(c, c + a)),
                    d = mpd(n, 1, .99, -30, 100);
               this.segments[r] = new Segment(r, [P[g + s][0], P[g + s][1], P[g + s][2], d], width * mpd(n, 0, 1, 1.2, .01), mpd(r, 0, cS, 0, 1), mpd(e, 0, 1, -.05, 2), t, h, i)
          }
          let r = mpp(rns[9], .25, .35) + i;
          this.xT = width * r * sin(t) + (width / 2 + width * arg.x), this.yT = width * r * cos(t) + (height / 2 + height * arg.y)
     }
     tck() {
          this.wPh += this.wSp * this.wRt;
          let t = sin(Math.PI / this.wFq * 2);
          this.wPh &gt; t &amp;&amp; (this.wPh -= t);
          for (let t = 0; t &lt; this.segments.length; t++) this.segments[t].tck(this.wPh, this.wSc, this.wFq);
          for (let t = 0; t &lt; this.segments.length; t++) this.segments[t].dO();
          for (let t = 0; t &lt; this.segments.length; t++) this.segments[t].dF()
     }
}
class Segment {
     constructor(t, s, h, i, r, e, n, a) {
          this.x = 0, this.y = 0, this.ix = t, this.cl = s, this.sz = h, this.sc = i, this.rd = r, this.rt = e, this.sp = n, this.xT = width * (r + a) * sin(e) + (width / 2 + width * arg.x), this.yT = width * (r + a) * cos(e) + (height / 2 + height * arg.y)
     }
     tck(t, s, h) {
          let i = s * sin(Math.PI / h * 2 * (this.ix + t));
          this.x = this.sc * (width * this.rd * sin(this.rt + this.sp + i) + .5 * width) + (1 - this.sc) * this.xT, this.y = this.sc * (width * this.rd * cos(this.rt + this.sp + i) + .5 * width) + (1 - this.sc) * this.yT
     }
     dO() {
          fill([sCol[0], sCol[1], sCol[2], this.cl[3]]), ellipse(this.x, this.y, this.sz + .25 * width * this.sc * this.sc, this.sz + .25 * width * this.sc * this.sc)
     }
     dF() {
          fill(this.cl), ellipse(this.x, this.y, this.sz, this.sz)
     }
}</pre></body></html>